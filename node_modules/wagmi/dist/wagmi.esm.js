import * as React from 'react';
import { getDefaultProvider } from '@ethersproject/providers';
import { erc20ABI, defaultChains, defaultL2Chains, ConnectorAlreadyConnectedError, allChains, SwitchChainError, ConnectorNotFoundError, UserRejectedRequestError, InjectedConnector } from 'wagmi-private';
export { AddChainError, ChainNotConfiguredError, Connector, ConnectorAlreadyConnectedError, ConnectorNotFoundError, InjectedConnector, SwitchChainError, UserRejectedRequestError, allChains, chain, defaultChains, defaultL2Chains, developmentChains, erc1155ABI, erc20ABI, erc721ABI, normalizeChainId } from 'wagmi-private';
import { utils, ethers, Contract } from 'ethers';

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}

var useProvider = () => {
  var {
    state
  } = useContext();
  return state.provider;
};

var useWebSocketProvider = () => {
  var {
    state
  } = useContext();
  return state.webSocketProvider;
};

var useCacheBuster = () => {
  var context = useContext();
  return context.state.cacheBuster;
};

var useLocalStorage = function useLocalStorage(key) {
  var defaultState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var [value, setValue] = React.useState(() => {
    if (typeof localStorage === 'undefined') return defaultState;
    var value = localStorage.getItem(key);

    try {
      return value ? JSON.parse(value) : defaultState;
    } catch (error) {
      console.warn(error);
      return defaultState;
    }
  });
  var setLocalStorage = React.useCallback(newValue => {
    if (newValue === value) return;
    setValue(newValue);
    if (newValue === null) localStorage.removeItem(key);else localStorage.setItem(key, JSON.stringify(newValue));

    if (newValue === null) {
      localStorage.removeItem(key);
    } else {
      try {
        localStorage.setItem(key, JSON.stringify(newValue));
      } catch (error) {
        console.error(error);
      }
    }
  }, [value, setValue, key]);
  return [value, setLocalStorage];
};

var initialState$e = {
  loading: false
};
var useEnsAvatar = function useEnsAvatar() {
  var {
    addressOrName,
    skip
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var cacheBuster = useCacheBuster();
  var provider = useProvider();
  var [state, setState] = React.useState(initialState$e);
  var getEnsAvatar = React.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (config) {
      try {
        var config_ = config !== null && config !== void 0 ? config : {
          addressOrName
        };
        if (!config_.addressOrName) throw new Error('addressOrName is required');
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error: undefined,
          loading: true
        }));
        var avatar = yield provider.getAvatar(config_.addressOrName);
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          avatar,
          loading: false
        }));
        return avatar;
      } catch (error_) {
        var error = error_;
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error,
          loading: false
        }));
        return error;
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [addressOrName, provider]); // Fetch avatar when deps or chain changes

  /* eslint-disable react-hooks/exhaustive-deps */

  React.useEffect(() => {
    if (skip || !addressOrName) return;
    var didCancel = false;
    if (didCancel) return;
    getEnsAvatar({
      addressOrName
    });
    return () => {
      didCancel = true;
    };
  }, [addressOrName, cacheBuster, skip]);
  /* eslint-enable react-hooks/exhaustive-deps */

  return [{
    data: state.avatar,
    loading: state.loading,
    error: state.error
  }, getEnsAvatar];
};

var initialState$d = {
  loading: false
};
var useEnsLookup = function useEnsLookup() {
  var {
    address,
    skip
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var cacheBuster = useCacheBuster();
  var provider = useProvider();
  var [state, setState] = React.useState(initialState$d);
  var lookupAddress = React.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (config) {
      try {
        var config_ = config !== null && config !== void 0 ? config : {
          address
        };
        if (!config_.address) throw new Error('address is required');
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error: undefined,
          loading: true
        }));
        var ens = yield provider.lookupAddress(config_.address);
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          ens,
          loading: false
        }));
        return {
          data: ens,
          error: undefined
        };
      } catch (error_) {
        var error = error_;
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error,
          loading: false
        }));
        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [address, provider]);
  /* eslint-disable react-hooks/exhaustive-deps */

  React.useEffect(() => {
    if (skip || !address) return;
    var didCancel = false;
    if (didCancel) return;
    lookupAddress({
      address
    });
    return () => {
      didCancel = true;
    };
  }, [address, cacheBuster, skip]);
  /* eslint-enable react-hooks/exhaustive-deps */

  return [{
    data: state.ens,
    loading: state.loading,
    error: state.error
  }, lookupAddress];
};

var initialState$c = {
  loading: false
};
var useEnsResolver = function useEnsResolver() {
  var {
    name,
    skip
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var cacheBuster = useCacheBuster();
  var provider = useProvider();
  var [state, setState] = React.useState(initialState$c);
  var getEnsResolver = React.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (config) {
      try {
        var config_ = config !== null && config !== void 0 ? config : {
          name
        };
        if (!config_.name) throw new Error('name is required');
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error: undefined,
          loading: true
        }));
        var resolver = yield provider.getResolver(config_.name);
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          loading: false,
          resolver
        }));
        return {
          data: resolver,
          error: undefined
        };
      } catch (error_) {
        var error = error_;
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error,
          loading: false
        }));
        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [name, provider]); // Fetch avatar when deps or chain changes

  /* eslint-disable react-hooks/exhaustive-deps */

  React.useEffect(() => {
    if (skip || !name) return;
    var didCancel = false;
    if (didCancel) return;
    getEnsResolver({
      name
    });
    return () => {
      didCancel = true;
    };
  }, [name, cacheBuster, skip]);
  /* eslint-enable react-hooks/exhaustive-deps */

  return [{
    data: state.resolver,
    loading: state.loading,
    error: state.error
  }, getEnsResolver];
};

var useAccount = function useAccount() {
  var _globalState$data;

  var {
    fetchEns
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var {
    state: globalState,
    setState
  } = useContext();
  var address = (_globalState$data = globalState.data) === null || _globalState$data === void 0 ? void 0 : _globalState$data.account;
  var [{
    data: ens,
    error: ensError,
    loading: ensLoading
  }] = useEnsLookup({
    address,
    skip: !fetchEns
  });
  var [{
    data: avatar,
    error: avatarError,
    loading: avatarLoading
  }] = useEnsAvatar({
    addressOrName: ens,
    skip: !fetchEns || !ens
  });
  var disconnect = React.useCallback(() => {
    setState(x => {
      var _x$connector;

      (_x$connector = x.connector) === null || _x$connector === void 0 ? void 0 : _x$connector.disconnect();
      return {
        cacheBuster: x.cacheBuster + 1
      };
    });
  }, [setState]);
  var error = ensError || avatarError;
  var loading = ensLoading || avatarLoading;
  return [{
    data: address ? {
      address,
      connector: globalState.connector,
      ens: ens ? {
        avatar,
        name: ens
      } : undefined
    } : undefined,
    error,
    loading
  }, disconnect];
};

var initialState$b = {
  loading: false
};
var useBlockNumber = function useBlockNumber() {
  var {
    skip,
    watch
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var provider = useProvider();
  var webSocketProvider = useWebSocketProvider();
  var [state, setState] = React.useState(initialState$b);
  var getBlockNumber = React.useCallback( /*#__PURE__*/_asyncToGenerator(function* () {
    try {
      setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
        error: undefined,
        loading: true
      }));
      var blockNumber = yield provider.getBlockNumber();
      setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
        blockNumber,
        loading: false
      }));
      return {
        data: blockNumber,
        error: undefined
      };
    } catch (error_) {
      var error = error_;
      setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
        error,
        loading: false
      }));
      return {
        data: undefined,
        error
      };
    }
  }), [provider]);
  /* eslint-disable react-hooks/exhaustive-deps */

  React.useEffect(() => {
    if (skip) return;
    var didCancel = false;
    if (didCancel) return;
    getBlockNumber();
    return () => {
      didCancel = true;
    };
  }, [skip]);
  /* eslint-enable react-hooks/exhaustive-deps */

  /* eslint-disable react-hooks/exhaustive-deps */

  React.useEffect(() => {
    if (!watch) return;

    var listener = blockNumber => setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
      blockNumber
    }));

    var provider_ = webSocketProvider !== null && webSocketProvider !== void 0 ? webSocketProvider : provider;
    provider_.on('block', listener);
    return () => {
      provider_.off('block', listener);
    };
  }, []);
  /* eslint-enable react-hooks/exhaustive-deps */

  return [{
    data: state.blockNumber,
    error: state.error,
    loading: state.loading
  }, getBlockNumber];
};

var initialState$a = {
  loading: false
};
var useFeeData = function useFeeData() {
  var {
    formatUnits = 'wei',
    skip,
    watch
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var provider = useProvider();
  var [{
    data: blockNumber
  }] = useBlockNumber({
    skip: true,
    watch
  });
  var cacheBuster = useCacheBuster();
  var [state, setState] = React.useState(initialState$a);
  var getFeeData = React.useCallback( /*#__PURE__*/_asyncToGenerator(function* () {
    try {
      setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
        error: undefined,
        loading: true
      }));
      var feeData = yield provider.getFeeData();
      setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
        feeData,
        loading: false
      }));
      return {
        data: feeData,
        error: undefined
      };
    } catch (error_) {
      var error = error_;
      setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
        error,
        loading: false
      }));
      return {
        data: undefined,
        error
      };
    }
  }), [provider]); // Fetch feeData on mount or when chain changes

  /* eslint-disable react-hooks/exhaustive-deps */

  React.useEffect(() => {
    if (skip) return;
    var didCancel = false;
    if (didCancel) return;
    getFeeData();
    return () => {
      didCancel = true;
    };
  }, [cacheBuster, skip]);
  /* eslint-enable react-hooks/exhaustive-deps */

  /* eslint-disable react-hooks/exhaustive-deps */

  React.useEffect(() => {
    if (!watch) return;
    if (!blockNumber) return;
    getFeeData();
  }, [blockNumber]);
  /* eslint-enable react-hooks/exhaustive-deps */

  var formatted = state.feeData ? {
    gasPrice: utils.formatUnits(state.feeData.gasPrice, formatUnits),
    maxFeePerGas: utils.formatUnits(state.feeData.maxFeePerGas, formatUnits),
    maxPriorityFeePerGas: utils.formatUnits(state.feeData.maxPriorityFeePerGas, formatUnits)
  } : undefined;
  return [{
    data: state.feeData ? _objectSpread2(_objectSpread2({}, state.feeData), {}, {
      formatted
    }) : undefined,
    loading: state.loading,
    error: state.error
  }, getFeeData];
};

var initialState$9 = {
  loading: false
};
var useBalance = function useBalance() {
  var {
    addressOrName,
    formatUnits = 'ether',
    skip,
    token,
    watch
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var {
    state: {
      connector
    }
  } = useContext();
  var cacheBuster = useCacheBuster();
  var provider = useProvider();
  var [{
    data: blockNumber
  }] = useBlockNumber({
    skip: true,
    watch
  });
  var [state, setState] = React.useState(initialState$9);
  var getBalance = React.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (config) {
      try {
        var _config_$formatUnits;

        var config_ = config !== null && config !== void 0 ? config : {
          addressOrName,
          formatUnits,
          token
        };
        if (!config_.addressOrName) throw new Error('address is required');
        var formatUnits_ = (_config_$formatUnits = config_.formatUnits) !== null && _config_$formatUnits !== void 0 ? _config_$formatUnits : 'ether';
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error: undefined,
          loading: true
        }));
        var balance;

        if (config_.token) {
          var contract = new ethers.Contract(config_.token, erc20ABI, provider);
          var value = yield contract.balanceOf(config_.addressOrName);
          var decimals = yield contract.decimals();
          var symbol = yield contract.symbol();
          balance = {
            decimals,
            formatted: utils.formatUnits(value, formatUnits_),
            symbol,
            value
          };
        } else {
          var _connector$chains, _chain$nativeCurrency, _chain$nativeCurrency2, _chain$nativeCurrency3, _chain$nativeCurrency4;

          var _value = yield provider.getBalance(config_.addressOrName);

          var chain = [...((_connector$chains = connector === null || connector === void 0 ? void 0 : connector.chains) !== null && _connector$chains !== void 0 ? _connector$chains : []), ...defaultChains, ...defaultL2Chains].find(x => x.id === provider.network.chainId);
          balance = {
            decimals: (_chain$nativeCurrency = chain === null || chain === void 0 ? void 0 : (_chain$nativeCurrency2 = chain.nativeCurrency) === null || _chain$nativeCurrency2 === void 0 ? void 0 : _chain$nativeCurrency2.decimals) !== null && _chain$nativeCurrency !== void 0 ? _chain$nativeCurrency : 18,
            formatted: utils.formatUnits(_value, formatUnits_),
            symbol: (_chain$nativeCurrency3 = chain === null || chain === void 0 ? void 0 : (_chain$nativeCurrency4 = chain.nativeCurrency) === null || _chain$nativeCurrency4 === void 0 ? void 0 : _chain$nativeCurrency4.symbol) !== null && _chain$nativeCurrency3 !== void 0 ? _chain$nativeCurrency3 : 'ETH',
            value: _value
          };
        }

        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          balance,
          loading: false
        }));
        return {
          data: balance,
          error: undefined
        };
      } catch (error_) {
        var error = error_;
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error,
          loading: false
        }));
        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [addressOrName, connector, formatUnits, provider, token]); // Fetch balance when deps or chain changes

  /* eslint-disable react-hooks/exhaustive-deps */

  React.useEffect(() => {
    if (skip || !addressOrName) return;
    var didCancel = false;
    if (didCancel) return;
    getBalance({
      addressOrName,
      formatUnits,
      token
    });
    return () => {
      didCancel = true;
    };
  }, [addressOrName, cacheBuster, skip, token]);
  /* eslint-enable react-hooks/exhaustive-deps */

  /* eslint-disable react-hooks/exhaustive-deps */

  React.useEffect(() => {
    if (!watch) return;
    if (!blockNumber) return;
    if (!addressOrName) return;
    getBalance({
      addressOrName,
      formatUnits,
      token
    });
  }, [blockNumber]);
  /* eslint-enable react-hooks/exhaustive-deps */

  return [{
    data: state.balance,
    error: state.error,
    loading: state.loading
  }, getBalance];
};

var initialState$8 = {
  loading: false
};
var useConnect = () => {
  var _globalState$data;

  var {
    state: globalState,
    setState: setGlobalState,
    setLastUsedConnector
  } = useContext();
  var [state, setState] = React.useState(initialState$8);
  var connect = React.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (connector) {
      try {
        var activeConnector = globalState === null || globalState === void 0 ? void 0 : globalState.connector;
        if (connector === activeConnector) throw new ConnectorAlreadyConnectedError();
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          loading: true,
          connector,
          error: undefined
        }));
        var data = yield connector.connect(); // Update connector globally only after successful connection

        setGlobalState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          connector,
          data
        }));
        setLastUsedConnector(connector.name);
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          loading: false
        }));
        return {
          data,
          error: undefined
        };
      } catch (error_) {
        var error = error_;
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          connector: undefined,
          error,
          loading: false
        }));
        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [globalState.connector, setGlobalState, setLastUsedConnector]); // Keep connector in sync with global connector

  React.useEffect(() => {
    var didCancel = false;
    if (didCancel) return;
    setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
      connector: globalState.connector,
      error: undefined
    }));
    return () => {
      didCancel = true;
    };
  }, [globalState.connector]);
  return [{
    data: {
      connected: !!((_globalState$data = globalState.data) !== null && _globalState$data !== void 0 && _globalState$data.account),
      connector: state.connector,
      connectors: globalState.connectors
    },
    error: state.error,
    loading: state.loading || globalState.connecting
  }, connect];
};

var initialState$7 = {
  loading: false
};
var useNetwork = () => {
  var _data$chain, _data$chain2, _connector$chains;

  var {
    state: {
      connector,
      data
    }
  } = useContext();
  var [state, setState] = React.useState(initialState$7);
  var chainId = data === null || data === void 0 ? void 0 : (_data$chain = data.chain) === null || _data$chain === void 0 ? void 0 : _data$chain.id;
  var unsupported = data === null || data === void 0 ? void 0 : (_data$chain2 = data.chain) === null || _data$chain2 === void 0 ? void 0 : _data$chain2.unsupported;
  var activeChains = (_connector$chains = connector === null || connector === void 0 ? void 0 : connector.chains) !== null && _connector$chains !== void 0 ? _connector$chains : [];
  var activeChain = [...activeChains, ...allChains].find(x => x.id === chainId);
  var switchNetwork = React.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (chainId) {
      if (!(connector !== null && connector !== void 0 && connector.switchChain)) return {
        data: undefined,
        error: new SwitchChainError()
      };

      try {
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error: undefined,
          loading: true
        }));
        var chain = yield connector.switchChain(chainId);
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          loading: false
        }));
        return {
          data: chain,
          error: undefined
        };
      } catch (error_) {
        var error = error_;
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error,
          loading: false
        }));
        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [connector]);
  return [{
    data: {
      chain: chainId ? _objectSpread2(_objectSpread2({}, activeChain), {}, {
        id: chainId,
        unsupported
      }) : undefined,
      chains: activeChains
    },
    error: state.error,
    loading: state.loading
  }, connector !== null && connector !== void 0 && connector.switchChain ? switchNetwork : undefined];
};

var initialState$6 = {
  data: undefined,
  error: undefined,
  loading: false
};
var useSigner = function useSigner() {
  var {
    skip
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var cacheBuster = useCacheBuster();
  var {
    state: {
      connector
    }
  } = useContext();
  var [state, setState] = React.useState(initialState$6);
  var getSigner = React.useCallback( /*#__PURE__*/_asyncToGenerator(function* () {
    try {
      setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
        error: undefined,
        loading: true
      }));
      var signer = yield connector === null || connector === void 0 ? void 0 : connector.getSigner();
      setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
        data: signer,
        loading: false
      }));
      return signer;
    } catch (error_) {
      var error = error_;
      setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
        data: undefined,
        error,
        loading: false
      }));
    }
  }), [connector]);
  React.useEffect(() => {
    if (skip) return;
    var didCancel = false;
    if (didCancel) return;
    getSigner();
    return () => {
      didCancel = true;
    };
  }, [cacheBuster, connector, getSigner, skip]);
  return [state, getSigner];
};

var initialState$5 = {
  loading: false
};
var useSignMessage = function useSignMessage() {
  var {
    message
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var {
    state: {
      connector
    }
  } = useContext();
  var [state, setState] = React.useState(initialState$5);
  var signMessage = React.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (config) {
      try {
        var config_ = config !== null && config !== void 0 ? config : {
          message
        };
        if (!config_.message) throw new Error('message is required');
        if (!connector) throw new ConnectorNotFoundError();
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error: undefined,
          loading: true
        }));
        var signer = yield connector.getSigner();
        var signature = yield signer.signMessage(config_.message);
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          signature,
          loading: false
        }));
        return {
          data: signature,
          error: undefined
        };
      } catch (error_) {
        var error = error_;
        if (error_.code === 4001) error = new UserRejectedRequestError();
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error,
          loading: false
        }));
        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [connector, message]);
  return [{
    data: state.signature,
    error: state.error,
    loading: state.loading
  }, signMessage];
};

var getContract = _ref => {
  var {
    addressOrName,
    contractInterface,
    signerOrProvider
  } = _ref;
  return new Contract(addressOrName, contractInterface, signerOrProvider);
};

var useContract = _ref2 => {
  var {
    addressOrName,
    contractInterface,
    signerOrProvider
  } = _ref2;
  return React.useMemo(() => {
    return getContract({
      addressOrName,
      contractInterface,
      signerOrProvider
    });
  }, [addressOrName, contractInterface, signerOrProvider]);
};

var useContractEvent = function useContractEvent(contractConfig, eventName, listener) {
  var {
    once
  } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  var provider = useProvider();
  var webSocketProvider = useWebSocketProvider();
  var contract = useContract(_objectSpread2({
    signerOrProvider: webSocketProvider !== null && webSocketProvider !== void 0 ? webSocketProvider : provider
  }, contractConfig));
  var listenerRef = React.useRef(listener);
  listenerRef.current = listener;
  /* eslint-disable react-hooks/exhaustive-deps */

  React.useEffect(() => {
    var handler = function handler() {
      for (var _len = arguments.length, event = new Array(_len), _key = 0; _key < _len; _key++) {
        event[_key] = arguments[_key];
      }

      return listenerRef.current(event);
    };

    var contract_ = contract;
    if (once) contract_.once(eventName, handler);else contract_.on(eventName, handler);
    return () => {
      contract_.off(eventName, handler);
      return;
    };
  }, [contract, eventName]);
  /* eslint-enable react-hooks/exhaustive-deps */
};

var initialState$4 = {
  loading: false
};
var useContractRead = function useContractRead(contractConfig, functionName) {
  var {
    args,
    overrides,
    skip,
    watch
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var provider = useProvider();
  var contract = useContract(_objectSpread2({
    signerOrProvider: provider
  }, contractConfig));
  var [{
    data: blockNumber
  }] = useBlockNumber({
    skip: true,
    watch
  });
  var [state, setState] = React.useState(initialState$4);
  var read = React.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (config) {
      try {
        var config_ = config !== null && config !== void 0 ? config : {
          args,
          overrides
        };
        var params = [...(Array.isArray(config_.args) ? config_.args : config_.args ? [config_.args] : []), ...(config_.overrides ? [config_.overrides] : [])];
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error: undefined,
          loading: true,
          response: undefined
        }));
        var response = yield contract[functionName](...params);
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          loading: false,
          response
        }));
        return {
          data: response,
          error: undefined
        };
      } catch (error_) {
        var error = error_;
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error,
          loading: false
        }));
        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [args, contract, functionName, overrides]);
  /* eslint-disable react-hooks/exhaustive-deps */

  React.useEffect(() => {
    if (skip) return;
    var didCancel = false;
    if (didCancel) return;
    read({
      args,
      overrides
    });
    return () => {
      didCancel = true;
    };
  }, [args, overrides, skip]);
  /* eslint-enable react-hooks/exhaustive-deps */

  /* eslint-disable react-hooks/exhaustive-deps */

  React.useEffect(() => {
    if (!watch) return;
    if (!blockNumber) return;
    read({
      args,
      overrides
    });
  }, [blockNumber]);
  /* eslint-enable react-hooks/exhaustive-deps */

  return [{
    data: state.response,
    error: state.error,
    loading: state.loading
  }, read];
};

var initialState$3 = {
  loading: false
};
var useContractWrite = function useContractWrite(contractConfig, functionName) {
  var {
    args,
    overrides
  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var {
    state: {
      connector
    }
  } = useContext();
  var contract = useContract(contractConfig);
  var [state, setState] = React.useState(initialState$3);
  var write = React.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (config) {
      try {
        var config_ = config !== null && config !== void 0 ? config : {
          args,
          overrides
        };
        if (!connector) throw new ConnectorNotFoundError();
        var params = [...(Array.isArray(config_.args) ? config_.args : config_.args ? [config_.args] : []), ...(config_.overrides ? [config_.overrides] : [])];
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error: undefined,
          loading: true,
          response: undefined
        }));
        var signer = yield connector.getSigner();
        var contract_ = contract.connect(signer);
        var response = yield contract_[functionName](...params);
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          loading: false,
          response
        }));
        return {
          data: response,
          error: undefined
        };
      } catch (error_) {
        var error = error_;
        if (error_.code === 4001) error = new UserRejectedRequestError();
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error,
          loading: false
        }));
        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [args, connector, contract, functionName, overrides]);
  return [{
    data: state.response,
    error: state.error,
    loading: state.loading
  }, write];
};

var initialState$2 = {
  loading: false
};
var useToken = function useToken() {
  var {
    address,
    formatUnits = 'ether',
    skip
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var {
    state: {
      connector
    }
  } = useContext();
  var provider = useProvider();
  var [state, setState] = React.useState(initialState$2);
  var getToken = React.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (config) {
      try {
        var _config_$formatUnits;

        var config_ = config !== null && config !== void 0 ? config : {
          address,
          formatUnits
        };
        if (!config_.address) throw new Error('address is required');
        var contract = new ethers.Contract(config_.address, erc20ABI, provider);
        var formatUnits_ = (_config_$formatUnits = config_.formatUnits) !== null && _config_$formatUnits !== void 0 ? _config_$formatUnits : 'ether';
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error: undefined,
          loading: true
        }));
        var symbol = yield contract.symbol();
        var decimals = yield contract.decimals();
        var totalSupply = yield contract.totalSupply();
        var token = {
          address: config_.address,
          decimals,
          symbol,
          totalSupply: {
            formatted: utils.formatUnits(totalSupply, formatUnits_),
            value: totalSupply
          }
        };
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          token,
          loading: false
        }));
        return {
          data: token,
          error: undefined
        };
      } catch (error_) {
        var error = error_;
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error,
          loading: false
        }));
        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [address, formatUnits, provider]);
  var watchToken = React.useCallback( /*#__PURE__*/function () {
    var _ref2 = _asyncToGenerator(function* (token) {
      if (!(connector !== null && connector !== void 0 && connector.watchAsset)) return false;

      try {
        yield connector.watchAsset(token);
        return true;
      } catch (error) {
        return error;
      }
    });

    return function (_x2) {
      return _ref2.apply(this, arguments);
    };
  }(), [connector]);
  /* eslint-disable react-hooks/exhaustive-deps */

  React.useEffect(() => {
    if (skip || !address) return;
    var didCancel = false;
    if (didCancel) return;
    getToken({
      address,
      formatUnits
    });
    return () => {
      didCancel = true;
    };
  }, [address, skip]);
  /* eslint-enable react-hooks/exhaustive-deps */

  return [{
    data: state.token ? _objectSpread2(_objectSpread2({}, state.token), {}, {
      address
    }) : undefined,
    error: state.error,
    loading: state.loading
  }, watchToken, getToken];
};

var initialState$1 = {
  loading: false
};
var useTransaction = function useTransaction() {
  var {
    request
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var {
    state: {
      connector
    }
  } = useContext();
  var [state, setState] = React.useState(initialState$1);
  var sendTransaction = React.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (config) {
      try {
        var config_ = config !== null && config !== void 0 ? config : {
          request
        };
        if (!config_.request) throw new Error('request is required');
        if (!connector) throw new ConnectorNotFoundError();
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          loading: true
        }));
        var signer = yield connector.getSigner();
        var transaction = yield signer.sendTransaction(config_.request);
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          loading: false,
          transaction
        }));
        return {
          data: transaction,
          error: undefined
        };
      } catch (error_) {
        var error = error_;
        if (error_.code === 4001) error = new UserRejectedRequestError();
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error,
          loading: false
        }));
        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [connector, request]);
  return [{
    data: state.transaction,
    error: state.error,
    loading: state.loading
  }, sendTransaction];
};

var initialState = {
  loading: false
};
var useWaitForTransaction = function useWaitForTransaction() {
  var {
    confirmations,
    hash,
    skip,
    timeout,
    wait: wait_
  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var provider = useProvider();
  var [state, setState] = React.useState(initialState);
  var wait = React.useCallback( /*#__PURE__*/function () {
    var _ref = _asyncToGenerator(function* (config) {
      try {
        var config_ = config !== null && config !== void 0 ? config : {
          confirmations,
          hash,
          timeout,
          wait: wait_
        };
        if (!config_.hash && !config_.wait) throw new Error('hash or wait is required');
        var promise; // eslint-disable-next-line testing-library/await-async-utils

        if (config_.wait) promise = config_.wait(config_.confirmations);else if (config_.hash) promise = provider.waitForTransaction(config_.hash, config_.confirmations, config_.timeout);else throw new Error('hash or wait is required');
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          loading: true
        }));
        var receipt = yield promise;
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          loading: false,
          receipt
        }));
        return {
          data: receipt,
          error: undefined
        };
      } catch (error_) {
        var error = error_;
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          error,
          loading: false
        }));
        return {
          data: undefined,
          error
        };
      }
    });

    return function (_x) {
      return _ref.apply(this, arguments);
    };
  }(), [wait_, confirmations, hash, timeout, provider]); // Fetch balance when deps or chain changes

  /* eslint-disable react-hooks/exhaustive-deps */

  React.useEffect(() => {
    if (skip || !hash && !wait_) return;
    var didCancel = false;
    if (didCancel) return; // eslint-disable-next-line testing-library/await-async-utils

    wait({
      confirmations,
      hash,
      timeout,
      wait: wait_
    });
    return () => {
      didCancel = true;
    };
  }, [wait_, hash, skip]);
  /* eslint-enable react-hooks/exhaustive-deps */

  return [{
    data: state.receipt,
    error: state.error,
    loading: state.loading
  }, wait];
};

var Context = /*#__PURE__*/React.createContext(null);
var Provider = _ref => {
  var _state$data2, _state$data2$chain, _state$data4, _state$data4$chain, _state$data6, _state$data6$chain;

  var {
    autoConnect = false,
    children,
    connectors: connectors_ = [new InjectedConnector()],
    connectorStorageKey = 'wagmi.wallet',
    provider: provider_ = getDefaultProvider(),
    webSocketProvider: webSocketProvider_
  } = _ref;
  var [lastUsedConnector, setLastUsedConnector] = useLocalStorage(connectorStorageKey);
  var [state, setState] = React.useState({
    cacheBuster: 1,
    connecting: autoConnect
  });
  var connectors = React.useMemo(() => {
    var _state$data, _state$data$chain;

    if (typeof connectors_ !== 'function') return connectors_;
    return connectors_({
      chainId: (_state$data = state.data) === null || _state$data === void 0 ? void 0 : (_state$data$chain = _state$data.chain) === null || _state$data$chain === void 0 ? void 0 : _state$data$chain.id
    });
  }, [connectors_, (_state$data2 = state.data) === null || _state$data2 === void 0 ? void 0 : (_state$data2$chain = _state$data2.chain) === null || _state$data2$chain === void 0 ? void 0 : _state$data2$chain.id]);
  var provider = React.useMemo(() => {
    var _state$data3, _state$data3$chain;

    if (typeof provider_ !== 'function') return provider_;
    return provider_({
      chainId: (_state$data3 = state.data) === null || _state$data3 === void 0 ? void 0 : (_state$data3$chain = _state$data3.chain) === null || _state$data3$chain === void 0 ? void 0 : _state$data3$chain.id,
      connector: state.connector
    });
  }, [provider_, (_state$data4 = state.data) === null || _state$data4 === void 0 ? void 0 : (_state$data4$chain = _state$data4.chain) === null || _state$data4$chain === void 0 ? void 0 : _state$data4$chain.id, state.connector]);
  var webSocketProvider = React.useMemo(() => {
    var _state$data5, _state$data5$chain;

    if (!webSocketProvider_) return undefined;
    if (typeof webSocketProvider_ !== 'function') return webSocketProvider_;
    return webSocketProvider_({
      chainId: (_state$data5 = state.data) === null || _state$data5 === void 0 ? void 0 : (_state$data5$chain = _state$data5.chain) === null || _state$data5$chain === void 0 ? void 0 : _state$data5$chain.id,
      connector: state.connector
    });
  }, [webSocketProvider_, (_state$data6 = state.data) === null || _state$data6 === void 0 ? void 0 : (_state$data6$chain = _state$data6.chain) === null || _state$data6$chain === void 0 ? void 0 : _state$data6$chain.id, state.connector]); // Attempt to connect on mount

  /* eslint-disable react-hooks/exhaustive-deps */

  React.useEffect(() => {
    if (!autoConnect) return;

    _asyncToGenerator(function* () {
      setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
        connecting: true
      }));
      var sorted = lastUsedConnector ? [...connectors].sort(x => x.name === lastUsedConnector ? -1 : 1) : connectors;

      var _loop = function* _loop(connector) {
        if (!connector.ready || !connector.isAuthorized) return "continue";
        var isAuthorized = yield connector.isAuthorized();
        if (!isAuthorized) return "continue";
        var data = yield connector.connect();
        setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
          connector,
          data
        }));
        return "break";
      };

      for (var connector of sorted) {
        var _ret = yield* _loop(connector);

        if (_ret === "continue") continue;
        if (_ret === "break") break;
      }

      setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
        connecting: false
      }));
    })();
  }, []);
  /* eslint-enable react-hooks/exhaustive-deps */
  // Make sure connectors close

  React.useEffect(() => {
    return () => {
      if (!state.connector) return;
      state.connector.disconnect();
    };
  }, [state.connector]); // Watch connector for events

  React.useEffect(() => {
    if (!state.connector) return;

    var onChange = data => setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
      cacheBuster: x.cacheBuster + 1,
      data: _objectSpread2(_objectSpread2({}, x.data), data)
    }));

    var onDisconnect = () => setState({
      cacheBuster: 1
    });

    var onError = error => setState(x => _objectSpread2(_objectSpread2({}, x), {}, {
      error
    }));

    state.connector.on('change', onChange);
    state.connector.on('disconnect', onDisconnect);
    state.connector.on('error', onError);
    return () => {
      if (!state.connector) return;
      state.connector.off('change', onChange);
      state.connector.off('disconnect', onDisconnect);
      state.connector.off('error', onError);
    };
  }, [state.connector]);
  var value = {
    state: {
      cacheBuster: state.cacheBuster,
      connecting: state.connecting,
      connectors,
      connector: state.connector,
      data: state.data,
      provider,
      webSocketProvider
    },
    setState,
    setLastUsedConnector
  };
  return /*#__PURE__*/React.createElement(Context.Provider, {
    value
  }, children);
};
var useContext = () => {
  var context = React.useContext(Context);
  if (!context) throw Error('Must be used within Provider');
  return context;
};

export { Context, Provider, useAccount, useBalance, useBlockNumber, useConnect, useContext, useContract, useContractEvent, useContractRead, useContractWrite, useEnsAvatar, useEnsLookup, useEnsResolver, useFeeData, useNetwork, useProvider, useSignMessage, useSigner, useToken, useTransaction, useWaitForTransaction, useWebSocketProvider };
