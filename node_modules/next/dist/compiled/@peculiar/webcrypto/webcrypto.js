(()=>{var t={862:(t,r,o)=>{"use strict";Object.defineProperty(r,"__esModule",{value:true});r.AsnConvert=void 0;const i=o(62);const a=o(7);const c=o(859);const l=o(350);class AsnConvert{static serialize(t){return l.AsnSerializer.serialize(t)}static parse(t,r){return c.AsnParser.parse(t,r)}static toString(t){const r=a.BufferSourceConverter.isBufferSource(t)?a.BufferSourceConverter.toArrayBuffer(t):AsnConvert.serialize(t);const o=i.fromBER(r);if(o.offset===-1){throw new Error(`Cannot decode ASN.1 data. ${o.result.error}`)}return o.result.toString()}}r.AsnConvert=AsnConvert},184:(t,r,o)=>{"use strict";Object.defineProperty(r,"__esModule",{value:true});r.defaultConverter=r.AsnNullConverter=r.AsnGeneralizedTimeConverter=r.AsnUTCTimeConverter=r.AsnCharacterStringConverter=r.AsnGeneralStringConverter=r.AsnVisibleStringConverter=r.AsnGraphicStringConverter=r.AsnIA5StringConverter=r.AsnVideotexStringConverter=r.AsnTeletexStringConverter=r.AsnPrintableStringConverter=r.AsnNumericStringConverter=r.AsnUniversalStringConverter=r.AsnBmpStringConverter=r.AsnUtf8StringConverter=r.AsnOctetStringConverter=r.AsnBooleanConverter=r.AsnObjectIdentifierConverter=r.AsnBitStringConverter=r.AsnIntegerArrayBufferConverter=r.AsnEnumeratedConverter=r.AsnIntegerConverter=r.AsnAnyConverter=void 0;const i=o(62);const a=o(422);r.AsnAnyConverter={fromASN:t=>t instanceof i.Null?null:t.valueBeforeDecode,toASN:t=>{if(t===null){return new i.Null}const r=i.fromBER(t);if(r.result.error){throw new Error(r.result.error)}return r.result}};r.AsnIntegerConverter={fromASN:t=>t.valueBlock.valueHex.byteLength>4?t.valueBlock.toString():t.valueBlock.valueDec,toASN:t=>new i.Integer({value:t})};r.AsnEnumeratedConverter={fromASN:t=>t.valueBlock.valueDec,toASN:t=>new i.Enumerated({value:t})};r.AsnIntegerArrayBufferConverter={fromASN:t=>t.valueBlock.valueHex,toASN:t=>new i.Integer({valueHex:t})};r.AsnBitStringConverter={fromASN:t=>t.valueBlock.valueHex,toASN:t=>new i.BitString({valueHex:t})};r.AsnObjectIdentifierConverter={fromASN:t=>t.valueBlock.toString(),toASN:t=>new i.ObjectIdentifier({value:t})};r.AsnBooleanConverter={fromASN:t=>t.valueBlock.value,toASN:t=>new i.Boolean({value:t})};r.AsnOctetStringConverter={fromASN:t=>t.valueBlock.valueHex,toASN:t=>new i.OctetString({valueHex:t})};function createStringConverter(t){return{fromASN:t=>t.valueBlock.value,toASN:r=>new t({value:r})}}r.AsnUtf8StringConverter=createStringConverter(i.Utf8String);r.AsnBmpStringConverter=createStringConverter(i.BmpString);r.AsnUniversalStringConverter=createStringConverter(i.UniversalString);r.AsnNumericStringConverter=createStringConverter(i.NumericString);r.AsnPrintableStringConverter=createStringConverter(i.PrintableString);r.AsnTeletexStringConverter=createStringConverter(i.TeletexString);r.AsnVideotexStringConverter=createStringConverter(i.VideotexString);r.AsnIA5StringConverter=createStringConverter(i.IA5String);r.AsnGraphicStringConverter=createStringConverter(i.GraphicString);r.AsnVisibleStringConverter=createStringConverter(i.VisibleString);r.AsnGeneralStringConverter=createStringConverter(i.GeneralString);r.AsnCharacterStringConverter=createStringConverter(i.CharacterString);r.AsnUTCTimeConverter={fromASN:t=>t.toDate(),toASN:t=>new i.UTCTime({valueDate:t})};r.AsnGeneralizedTimeConverter={fromASN:t=>t.toDate(),toASN:t=>new i.GeneralizedTime({valueDate:t})};r.AsnNullConverter={fromASN:t=>null,toASN:t=>new i.Null};function defaultConverter(t){switch(t){case a.AsnPropTypes.Any:return r.AsnAnyConverter;case a.AsnPropTypes.BitString:return r.AsnBitStringConverter;case a.AsnPropTypes.BmpString:return r.AsnBmpStringConverter;case a.AsnPropTypes.Boolean:return r.AsnBooleanConverter;case a.AsnPropTypes.CharacterString:return r.AsnCharacterStringConverter;case a.AsnPropTypes.Enumerated:return r.AsnEnumeratedConverter;case a.AsnPropTypes.GeneralString:return r.AsnGeneralStringConverter;case a.AsnPropTypes.GeneralizedTime:return r.AsnGeneralizedTimeConverter;case a.AsnPropTypes.GraphicString:return r.AsnGraphicStringConverter;case a.AsnPropTypes.IA5String:return r.AsnIA5StringConverter;case a.AsnPropTypes.Integer:return r.AsnIntegerConverter;case a.AsnPropTypes.Null:return r.AsnNullConverter;case a.AsnPropTypes.NumericString:return r.AsnNumericStringConverter;case a.AsnPropTypes.ObjectIdentifier:return r.AsnObjectIdentifierConverter;case a.AsnPropTypes.OctetString:return r.AsnOctetStringConverter;case a.AsnPropTypes.PrintableString:return r.AsnPrintableStringConverter;case a.AsnPropTypes.TeletexString:return r.AsnTeletexStringConverter;case a.AsnPropTypes.UTCTime:return r.AsnUTCTimeConverter;case a.AsnPropTypes.UniversalString:return r.AsnUniversalStringConverter;case a.AsnPropTypes.Utf8String:return r.AsnUtf8StringConverter;case a.AsnPropTypes.VideotexString:return r.AsnVideotexStringConverter;case a.AsnPropTypes.VisibleString:return r.AsnVisibleStringConverter;default:return null}}r.defaultConverter=defaultConverter},358:(t,r,o)=>{"use strict";Object.defineProperty(r,"__esModule",{value:true});r.AsnProp=r.AsnType=void 0;const i=o(184);const a=o(455);const AsnType=t=>r=>{let o;if(!a.schemaStorage.has(r)){o=a.schemaStorage.createDefault(r);a.schemaStorage.set(r,o)}else{o=a.schemaStorage.get(r)}Object.assign(o,t)};r.AsnType=AsnType;const AsnProp=t=>(r,o)=>{let c;if(!a.schemaStorage.has(r.constructor)){c=a.schemaStorage.createDefault(r.constructor);a.schemaStorage.set(r.constructor,c)}else{c=a.schemaStorage.get(r.constructor)}const l=Object.assign({},t);if(typeof l.type==="number"&&!l.converter){const a=i.defaultConverter(t.type);if(!a){throw new Error(`Cannot get default converter for property '${o}' of ${r.constructor.name}`)}l.converter=a}c.items[o]=l};r.AsnProp=AsnProp},422:(t,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:true});r.AsnPropTypes=r.AsnTypeTypes=void 0;var o;(function(t){t[t["Sequence"]=0]="Sequence";t[t["Set"]=1]="Set";t[t["Choice"]=2]="Choice"})(o=r.AsnTypeTypes||(r.AsnTypeTypes={}));var i;(function(t){t[t["Any"]=1]="Any";t[t["Boolean"]=2]="Boolean";t[t["OctetString"]=3]="OctetString";t[t["BitString"]=4]="BitString";t[t["Integer"]=5]="Integer";t[t["Enumerated"]=6]="Enumerated";t[t["ObjectIdentifier"]=7]="ObjectIdentifier";t[t["Utf8String"]=8]="Utf8String";t[t["BmpString"]=9]="BmpString";t[t["UniversalString"]=10]="UniversalString";t[t["NumericString"]=11]="NumericString";t[t["PrintableString"]=12]="PrintableString";t[t["TeletexString"]=13]="TeletexString";t[t["VideotexString"]=14]="VideotexString";t[t["IA5String"]=15]="IA5String";t[t["GraphicString"]=16]="GraphicString";t[t["VisibleString"]=17]="VisibleString";t[t["GeneralString"]=18]="GeneralString";t[t["CharacterString"]=19]="CharacterString";t[t["UTCTime"]=20]="UTCTime";t[t["GeneralizedTime"]=21]="GeneralizedTime";t[t["DATE"]=22]="DATE";t[t["TimeOfDay"]=23]="TimeOfDay";t[t["DateTime"]=24]="DateTime";t[t["Duration"]=25]="Duration";t[t["TIME"]=26]="TIME";t[t["Null"]=27]="Null"})(i=r.AsnPropTypes||(r.AsnPropTypes={}))},463:(t,r,o)=>{"use strict";Object.defineProperty(r,"__esModule",{value:true});const i=o(657);i.__exportStar(o(150),r)},150:(t,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:true});r.AsnSchemaValidationError=void 0;class AsnSchemaValidationError extends Error{constructor(){super(...arguments);this.schemas=[]}}r.AsnSchemaValidationError=AsnSchemaValidationError},83:(t,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:true});r.isArrayEqual=r.isTypeOfArray=r.isConvertible=void 0;function isConvertible(t){if(t&&t.prototype){if(t.prototype.toASN&&t.prototype.fromASN){return true}else{return isConvertible(t.prototype)}}else{return!!(t&&t.toASN&&t.fromASN)}}r.isConvertible=isConvertible;function isTypeOfArray(t){var r;if(t){const o=Object.getPrototypeOf(t);if(((r=o===null||o===void 0?void 0:o.prototype)===null||r===void 0?void 0:r.constructor)===Array){return true}return isTypeOfArray(o)}return false}r.isTypeOfArray=isTypeOfArray;function isArrayEqual(t,r){if(!(t&&r)){return false}if(t.byteLength!==r.byteLength){return false}const o=new Uint8Array(t);const i=new Uint8Array(r);for(let r=0;r<t.byteLength;r++){if(o[r]!==i[r]){return false}}return true}r.isArrayEqual=isArrayEqual},297:(t,r,o)=>{"use strict";Object.defineProperty(r,"__esModule",{value:true});r.AsnSerializer=r.AsnParser=r.AsnPropTypes=r.AsnTypeTypes=r.AsnType=r.AsnProp=void 0;const i=o(657);i.__exportStar(o(184),r);i.__exportStar(o(176),r);var a=o(358);Object.defineProperty(r,"AsnProp",{enumerable:true,get:function(){return a.AsnProp}});Object.defineProperty(r,"AsnType",{enumerable:true,get:function(){return a.AsnType}});var c=o(422);Object.defineProperty(r,"AsnTypeTypes",{enumerable:true,get:function(){return c.AsnTypeTypes}});Object.defineProperty(r,"AsnPropTypes",{enumerable:true,get:function(){return c.AsnPropTypes}});var l=o(859);Object.defineProperty(r,"AsnParser",{enumerable:true,get:function(){return l.AsnParser}});var u=o(350);Object.defineProperty(r,"AsnSerializer",{enumerable:true,get:function(){return u.AsnSerializer}});i.__exportStar(o(463),r);i.__exportStar(o(503),r);i.__exportStar(o(862),r)},503:(t,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:true});r.AsnArray=void 0;class AsnArray extends Array{constructor(t=[]){if(typeof t==="number"){super(t)}else{super();for(const r of t){this.push(r)}}}}r.AsnArray=AsnArray},859:(t,r,o)=>{"use strict";Object.defineProperty(r,"__esModule",{value:true});r.AsnParser=void 0;const i=o(62);const a=o(422);const c=o(184);const l=o(463);const u=o(83);const h=o(455);class AsnParser{static parse(t,r){let o;if(t instanceof ArrayBuffer){o=t}else if(typeof Buffer!=="undefined"&&Buffer.isBuffer(t)){o=new Uint8Array(t).buffer}else if(ArrayBuffer.isView(t)||t.buffer instanceof ArrayBuffer){o=t.buffer}else{throw new TypeError("Wrong type of 'data' argument")}const a=i.fromBER(o);if(a.result.error){throw new Error(a.result.error)}const c=this.fromASN(a.result,r);return c}static fromASN(t,r){var o;try{if(u.isConvertible(r)){const o=new r;return o.fromASN(t)}const y=h.schemaStorage.get(r);h.schemaStorage.cache(r);let p=y.schema;if(t.constructor===i.Constructed&&y.type!==a.AsnTypeTypes.Choice){p=new i.Constructed({idBlock:{tagClass:3,tagNumber:t.idBlock.tagNumber},value:y.schema.valueBlock.value});for(const r in y.items){delete t[r]}}const d=i.compareSchema(t,t,p);if(!d.verified){throw new l.AsnSchemaValidationError(`Data does not match to ${r.name} ASN1 schema. ${d.result.error}`)}const g=new r;if(u.isTypeOfArray(r)){if(typeof y.itemType==="number"){const o=c.defaultConverter(y.itemType);if(!o){throw new Error(`Cannot get default converter for array item of ${r.name} ASN1 schema`)}return r.from(t.valueBlock.value,(t=>o.fromASN(t)))}else{return r.from(t.valueBlock.value,(t=>this.fromASN(t,y.itemType)))}}for(const r in y.items){if(!t[r]){continue}const c=y.items[r];if(typeof c.type==="number"||u.isConvertible(c.type)){const l=(o=c.converter)!==null&&o!==void 0?o:u.isConvertible(c.type)?new c.type:null;if(!l){throw new Error("Converter is empty")}if(c.repeated){if(c.implicit){const o=c.repeated==="sequence"?i.Sequence:i.Set;const a=new o;a.valueBlock=t[r].valueBlock;const u=i.fromBER(a.toBER(false)).result.valueBlock.value;g[r]=Array.from(u,(t=>l.fromASN(t)))}else{g[r]=Array.from(t[r],(t=>l.fromASN(t)))}}else{let o=t[r];if(c.implicit){let t;if(u.isConvertible(c.type)){t=(new c.type).toSchema("")}else{const r=a.AsnPropTypes[c.type];const o=i[r];if(!o){throw new Error(`Cannot get '${r}' class from asn1js module`)}t=new o}t.valueBlock=o.valueBlock;o=i.fromBER(t.toBER(false)).result}g[r]=l.fromASN(o)}}else{if(c.repeated){g[r]=Array.from(t[r],(t=>this.fromASN(t,c.type)))}else{g[r]=this.fromASN(t[r],c.type)}}}return g}catch(t){if(t instanceof l.AsnSchemaValidationError){t.schemas.push(r.name)}throw t}}}r.AsnParser=AsnParser},855:(t,r,o)=>{"use strict";Object.defineProperty(r,"__esModule",{value:true});r.AsnSchemaStorage=void 0;const i=o(62);const a=o(422);const c=o(83);class AsnSchemaStorage{constructor(){this.items=new WeakMap}has(t){return this.items.has(t)}get(t){var r,o,i,a;const c=this.items.get(t);if(!c){throw new Error(`Cannot get schema for '${(a=(i=(o=(r=t)===null||r===void 0?void 0:r.prototype)===null||o===void 0?void 0:o.constructor)===null||i===void 0?void 0:i.name)!==null&&a!==void 0?a:t}' target`)}return c}cache(t){const r=this.get(t);if(!r.schema){r.schema=this.create(t,true)}}createDefault(t){const r={type:a.AsnTypeTypes.Sequence,items:{}};const o=this.findParentSchema(t);if(o){Object.assign(r,o);r.items=Object.assign({},r.items,o.items)}return r}create(t,r){const o=this.items.get(t)||this.createDefault(t);const l=[];for(const t in o.items){const u=o.items[t];const h=r?t:"";let y;if(typeof u.type==="number"){const t=a.AsnPropTypes[u.type];const r=i[t];if(!r){throw new Error(`Cannot get ASN1 class by name '${t}'`)}y=new r({name:h})}else if(c.isConvertible(u.type)){const t=new u.type;y=t.toSchema(h)}else if(u.optional){const t=this.get(u.type);if(t.type===a.AsnTypeTypes.Choice){y=new i.Any({name:h})}else{y=this.create(u.type,false);y.name=h}}else{y=new i.Any({name:h})}const p=!!u.optional||u.defaultValue!==undefined;if(u.repeated){y.name="";const t=u.repeated==="set"?i.Set:i.Sequence;y=new t({name:"",value:[new i.Repeated({name:h,value:y})]})}if(u.context!==null&&u.context!==undefined){if(u.implicit){if(typeof u.type==="number"||c.isConvertible(u.type)){const t=u.repeated?i.Constructed:i.Primitive;l.push(new t({name:h,optional:p,idBlock:{tagClass:3,tagNumber:u.context}}))}else{this.cache(u.type);const t=!!u.repeated;let r=!t?this.get(u.type).schema:y;r=r.valueBlock?r.valueBlock.value:r.value;l.push(new i.Constructed({name:!t?h:"",optional:p,idBlock:{tagClass:3,tagNumber:u.context},value:r}))}}else{l.push(new i.Constructed({optional:p,idBlock:{tagClass:3,tagNumber:u.context},value:[y]}))}}else{y.optional=p;l.push(y)}}switch(o.type){case a.AsnTypeTypes.Sequence:return new i.Sequence({value:l,name:""});case a.AsnTypeTypes.Set:return new i.Set({value:l,name:""});case a.AsnTypeTypes.Choice:return new i.Choice({value:l,name:""});default:throw new Error(`Unsupported ASN1 type in use`)}}set(t,r){this.items.set(t,r);return this}findParentSchema(t){const r=t.__proto__;if(r){const t=this.items.get(r);return t||this.findParentSchema(r)}return null}}r.AsnSchemaStorage=AsnSchemaStorage},350:(t,r,o)=>{"use strict";Object.defineProperty(r,"__esModule",{value:true});r.AsnSerializer=void 0;const i=o(62);const a=o(184);const c=o(422);const l=o(83);const u=o(455);class AsnSerializer{static serialize(t){if(t instanceof i.BaseBlock){return t.toBER(false)}return this.toASN(t).toBER(false)}static toASN(t){if(t&&l.isConvertible(t.constructor)){return t.toASN()}const r=t.constructor;const o=u.schemaStorage.get(r);u.schemaStorage.cache(r);let h=[];if(o.itemType){if(typeof o.itemType==="number"){const i=a.defaultConverter(o.itemType);if(!i){throw new Error(`Cannot get default converter for array item of ${r.name} ASN1 schema`)}h=t.map((t=>i.toASN(t)))}else{h=t.map((t=>this.toAsnItem({type:o.itemType},"[]",r,t)))}}else{for(const a in o.items){const c=o.items[a];const u=t[a];if(u===undefined||c.defaultValue===u||typeof c.defaultValue==="object"&&typeof u==="object"&&l.isArrayEqual(this.serialize(c.defaultValue),this.serialize(u))){continue}let y=AsnSerializer.toAsnItem(c,a,r,u);if(typeof c.context==="number"){if(c.implicit){if(!c.repeated&&(typeof c.type==="number"||l.isConvertible(c.type))){const t={};t.valueHex=y instanceof i.Null?y.valueBeforeDecode:y.valueBlock.toBER();h.push(new i.Primitive(Object.assign({optional:c.optional,idBlock:{tagClass:3,tagNumber:c.context}},t)))}else{h.push(new i.Constructed({optional:c.optional,idBlock:{tagClass:3,tagNumber:c.context},value:y.valueBlock.value}))}}else{h.push(new i.Constructed({optional:c.optional,idBlock:{tagClass:3,tagNumber:c.context},value:[y]}))}}else if(c.repeated){h=h.concat(y)}else{h.push(y)}}}let y;switch(o.type){case c.AsnTypeTypes.Sequence:y=new i.Sequence({value:h});break;case c.AsnTypeTypes.Set:y=new i.Set({value:h});break;case c.AsnTypeTypes.Choice:if(!h[0]){throw new Error(`Schema '${r.name}' has wrong data. Choice cannot be empty.`)}y=h[0];break}return y}static toAsnItem(t,r,o,a){let l;if(typeof t.type==="number"){const u=t.converter;if(!u){throw new Error(`Property '${r}' doesn't have converter for type ${c.AsnPropTypes[t.type]} in schema '${o.name}'`)}if(t.repeated){const r=Array.from(a,(t=>u.toASN(t)));const o=t.repeated==="sequence"?i.Sequence:i.Set;l=new o({value:r})}else{l=u.toASN(a)}}else{if(t.repeated){const r=Array.from(a,(t=>this.toASN(t)));const o=t.repeated==="sequence"?i.Sequence:i.Set;l=new o({value:r})}else{l=this.toASN(a)}}return l}}r.AsnSerializer=AsnSerializer},455:(t,r,o)=>{"use strict";Object.defineProperty(r,"__esModule",{value:true});r.schemaStorage=void 0;const i=o(855);r.schemaStorage=new i.AsnSchemaStorage},154:(t,r,o)=>{"use strict";Object.defineProperty(r,"__esModule",{value:true});r.BitString=void 0;const i=o(62);const a=o(7);class BitString{constructor(t,r=0){this.unusedBits=0;this.value=new ArrayBuffer(0);if(t){if(typeof t==="number"){this.fromNumber(t)}else if(a.BufferSourceConverter.isBufferSource(t)){this.unusedBits=r;this.value=a.BufferSourceConverter.toArrayBuffer(t)}else{throw TypeError("Unsupported type of 'params' argument for BitString")}}}fromASN(t){if(!(t instanceof i.BitString)){throw new TypeError("Argument 'asn' is not instance of ASN.1 BitString")}this.unusedBits=t.valueBlock.unusedBits;this.value=t.valueBlock.valueHex;return this}toASN(){return new i.BitString({unusedBits:this.unusedBits,valueHex:this.value})}toSchema(t){return new i.BitString({name:t})}toNumber(){let t="";const r=new Uint8Array(this.value);for(const o of r){t+=o.toString(2).padStart(8,"0")}t=t.split("").reverse().join("");if(this.unusedBits){t=t.slice(this.unusedBits).padStart(this.unusedBits,"0")}return parseInt(t,2)}fromNumber(t){let r=t.toString(2);const o=r.length+7>>3;this.unusedBits=(o<<3)-r.length;const i=new Uint8Array(o);r=r.padStart(o<<3,"0").split("").reverse().join("");let a=0;while(a<o){i[a]=parseInt(r.slice(a<<3,(a<<3)+8),2);a++}this.value=i.buffer}}r.BitString=BitString},176:(t,r,o)=>{"use strict";Object.defineProperty(r,"__esModule",{value:true});const i=o(657);i.__exportStar(o(154),r);i.__exportStar(o(481),r)},481:(t,r,o)=>{"use strict";Object.defineProperty(r,"__esModule",{value:true});r.OctetString=void 0;const i=o(62);const a=o(7);class OctetString{constructor(t){if(typeof t==="number"){this.buffer=new ArrayBuffer(t)}else{if(a.BufferSourceConverter.isBufferSource(t)){this.buffer=a.BufferSourceConverter.toArrayBuffer(t)}else if(Array.isArray(t)){this.buffer=new Uint8Array(t)}else{this.buffer=new ArrayBuffer(0)}}}get byteLength(){return this.buffer.byteLength}get byteOffset(){return 0}fromASN(t){if(!(t instanceof i.OctetString)){throw new TypeError("Argument 'asn' is not instance of ASN.1 OctetString")}this.buffer=t.valueBlock.valueHex;return this}toASN(){return new i.OctetString({valueHex:this.buffer})}toSchema(t){return new i.OctetString({name:t})}}r.OctetString=OctetString},657:t=>{
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var r;var o;var i;var a;var c;var l;var u;var h;var y;var p;var d;var g;var m;var v;var b;var w;var A;var B;var S;var k;var C;var P;var E;var K;(function(r){var o=typeof global==="object"?global:typeof self==="object"?self:typeof this==="object"?this:{};if(typeof define==="function"&&define.amd){define("tslib",["exports"],(function(t){r(createExporter(o,createExporter(t)))}))}else if(true&&typeof t.exports==="object"){r(createExporter(o,createExporter(t.exports)))}else{r(createExporter(o))}function createExporter(t,r){if(t!==o){if(typeof Object.create==="function"){Object.defineProperty(t,"__esModule",{value:true})}else{t.__esModule=true}}return function(o,i){return t[o]=r?r(o,i):i}}})((function(t){var x=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var o in r)if(Object.prototype.hasOwnProperty.call(r,o))t[o]=r[o]};r=function(t,r){if(typeof r!=="function"&&r!==null)throw new TypeError("Class extends value "+String(r)+" is not a constructor or null");x(t,r);function __(){this.constructor=t}t.prototype=r===null?Object.create(r):(__.prototype=r.prototype,new __)};o=Object.assign||function(t){for(var r,o=1,i=arguments.length;o<i;o++){r=arguments[o];for(var a in r)if(Object.prototype.hasOwnProperty.call(r,a))t[a]=r[a]}return t};i=function(t,r){var o={};for(var i in t)if(Object.prototype.hasOwnProperty.call(t,i)&&r.indexOf(i)<0)o[i]=t[i];if(t!=null&&typeof Object.getOwnPropertySymbols==="function")for(var a=0,i=Object.getOwnPropertySymbols(t);a<i.length;a++){if(r.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(t,i[a]))o[i[a]]=t[i[a]]}return o};a=function(t,r,o,i){var a=arguments.length,c=a<3?r:i===null?i=Object.getOwnPropertyDescriptor(r,o):i,l;if(typeof Reflect==="object"&&typeof Reflect.decorate==="function")c=Reflect.decorate(t,r,o,i);else for(var u=t.length-1;u>=0;u--)if(l=t[u])c=(a<3?l(c):a>3?l(r,o,c):l(r,o))||c;return a>3&&c&&Object.defineProperty(r,o,c),c};c=function(t,r){return function(o,i){r(o,i,t)}};l=function(t,r){if(typeof Reflect==="object"&&typeof Reflect.metadata==="function")return Reflect.metadata(t,r)};u=function(t,r,o,i){function adopt(t){return t instanceof o?t:new o((function(r){r(t)}))}return new(o||(o=Promise))((function(o,a){function fulfilled(t){try{step(i.next(t))}catch(t){a(t)}}function rejected(t){try{step(i["throw"](t))}catch(t){a(t)}}function step(t){t.done?o(t.value):adopt(t.value).then(fulfilled,rejected)}step((i=i.apply(t,r||[])).next())}))};h=function(t,r){var o={label:0,sent:function(){if(c[0]&1)throw c[1];return c[1]},trys:[],ops:[]},i,a,c,l;return l={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(l[Symbol.iterator]=function(){return this}),l;function verb(t){return function(r){return step([t,r])}}function step(l){if(i)throw new TypeError("Generator is already executing.");while(o)try{if(i=1,a&&(c=l[0]&2?a["return"]:l[0]?a["throw"]||((c=a["return"])&&c.call(a),0):a.next)&&!(c=c.call(a,l[1])).done)return c;if(a=0,c)l=[l[0]&2,c.value];switch(l[0]){case 0:case 1:c=l;break;case 4:o.label++;return{value:l[1],done:false};case 5:o.label++;a=l[1];l=[0];continue;case 7:l=o.ops.pop();o.trys.pop();continue;default:if(!(c=o.trys,c=c.length>0&&c[c.length-1])&&(l[0]===6||l[0]===2)){o=0;continue}if(l[0]===3&&(!c||l[1]>c[0]&&l[1]<c[3])){o.label=l[1];break}if(l[0]===6&&o.label<c[1]){o.label=c[1];c=l;break}if(c&&o.label<c[2]){o.label=c[2];o.ops.push(l);break}if(c[2])o.ops.pop();o.trys.pop();continue}l=r.call(t,o)}catch(t){l=[6,t];a=0}finally{i=c=0}if(l[0]&5)throw l[1];return{value:l[0]?l[1]:void 0,done:true}}};y=function(t,r){for(var o in t)if(o!=="default"&&!Object.prototype.hasOwnProperty.call(r,o))K(r,t,o)};K=Object.create?function(t,r,o,i){if(i===undefined)i=o;Object.defineProperty(t,i,{enumerable:true,get:function(){return r[o]}})}:function(t,r,o,i){if(i===undefined)i=o;t[i]=r[o]};p=function(t){var r=typeof Symbol==="function"&&Symbol.iterator,o=r&&t[r],i=0;if(o)return o.call(t);if(t&&typeof t.length==="number")return{next:function(){if(t&&i>=t.length)t=void 0;return{value:t&&t[i++],done:!t}}};throw new TypeError(r?"Object is not iterable.":"Symbol.iterator is not defined.")};d=function(t,r){var o=typeof Symbol==="function"&&t[Symbol.iterator];if(!o)return t;var i=o.call(t),a,c=[],l;try{while((r===void 0||r-- >0)&&!(a=i.next()).done)c.push(a.value)}catch(t){l={error:t}}finally{try{if(a&&!a.done&&(o=i["return"]))o.call(i)}finally{if(l)throw l.error}}return c};g=function(){for(var t=[],r=0;r<arguments.length;r++)t=t.concat(d(arguments[r]));return t};m=function(){for(var t=0,r=0,o=arguments.length;r<o;r++)t+=arguments[r].length;for(var i=Array(t),a=0,r=0;r<o;r++)for(var c=arguments[r],l=0,u=c.length;l<u;l++,a++)i[a]=c[l];return i};v=function(t,r,o){if(o||arguments.length===2)for(var i=0,a=r.length,c;i<a;i++){if(c||!(i in r)){if(!c)c=Array.prototype.slice.call(r,0,i);c[i]=r[i]}}return t.concat(c||Array.prototype.slice.call(r))};b=function(t){return this instanceof b?(this.v=t,this):new b(t)};w=function(t,r,o){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var i=o.apply(t,r||[]),a,c=[];return a={},verb("next"),verb("throw"),verb("return"),a[Symbol.asyncIterator]=function(){return this},a;function verb(t){if(i[t])a[t]=function(r){return new Promise((function(o,i){c.push([t,r,o,i])>1||resume(t,r)}))}}function resume(t,r){try{step(i[t](r))}catch(t){settle(c[0][3],t)}}function step(t){t.value instanceof b?Promise.resolve(t.value.v).then(fulfill,reject):settle(c[0][2],t)}function fulfill(t){resume("next",t)}function reject(t){resume("throw",t)}function settle(t,r){if(t(r),c.shift(),c.length)resume(c[0][0],c[0][1])}};A=function(t){var r,o;return r={},verb("next"),verb("throw",(function(t){throw t})),verb("return"),r[Symbol.iterator]=function(){return this},r;function verb(i,a){r[i]=t[i]?function(r){return(o=!o)?{value:b(t[i](r)),done:i==="return"}:a?a(r):r}:a}};B=function(t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var r=t[Symbol.asyncIterator],o;return r?r.call(t):(t=typeof p==="function"?p(t):t[Symbol.iterator](),o={},verb("next"),verb("throw"),verb("return"),o[Symbol.asyncIterator]=function(){return this},o);function verb(r){o[r]=t[r]&&function(o){return new Promise((function(i,a){o=t[r](o),settle(i,a,o.done,o.value)}))}}function settle(t,r,o,i){Promise.resolve(i).then((function(r){t({value:r,done:o})}),r)}};S=function(t,r){if(Object.defineProperty){Object.defineProperty(t,"raw",{value:r})}else{t.raw=r}return t};var O=Object.create?function(t,r){Object.defineProperty(t,"default",{enumerable:true,value:r})}:function(t,r){t["default"]=r};k=function(t){if(t&&t.__esModule)return t;var r={};if(t!=null)for(var o in t)if(o!=="default"&&Object.prototype.hasOwnProperty.call(t,o))K(r,t,o);O(r,t);return r};C=function(t){return t&&t.__esModule?t:{default:t}};P=function(t,r,o,i){if(o==="a"&&!i)throw new TypeError("Private accessor was defined without a getter");if(typeof r==="function"?t!==r||!i:!r.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return o==="m"?i:o==="a"?i.call(t):i?i.value:r.get(t)};E=function(t,r,o,i,a){if(i==="m")throw new TypeError("Private method is not writable");if(i==="a"&&!a)throw new TypeError("Private accessor was defined without a setter");if(typeof r==="function"?t!==r||!a:!r.has(t))throw new TypeError("Cannot write private member to an object whose class did not declare it");return i==="a"?a.call(t,o):a?a.value=o:r.set(t,o),o};t("__extends",r);t("__assign",o);t("__rest",i);t("__decorate",a);t("__param",c);t("__metadata",l);t("__awaiter",u);t("__generator",h);t("__exportStar",y);t("__createBinding",K);t("__values",p);t("__read",d);t("__spread",g);t("__spreadArrays",m);t("__spreadArray",v);t("__await",b);t("__asyncGenerator",w);t("__asyncDelegator",A);t("__asyncValues",B);t("__makeTemplateObject",S);t("__importStar",k);t("__importDefault",C);t("__classPrivateFieldGet",P);t("__classPrivateFieldSet",E)}))},628:(t,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:true});class JsonError extends Error{constructor(t,r){super(r?`${t}. See the inner exception for more details.`:t);this.message=t;this.innerError=r}}class TransformError extends JsonError{constructor(t,r,o){super(r,o);this.schema=t}}class ParserError extends TransformError{constructor(t,r,o){super(t,`JSON doesn't match to '${t.target.name}' schema. ${r}`,o)}}class ValidationError extends JsonError{}class SerializerError extends JsonError{constructor(t,r,o){super(`Cannot serialize by '${t}' schema. ${r}`,o);this.schemaName=t}}class KeyError extends ParserError{constructor(t,r,o={}){super(t,"Some keys doesn't match to schema");this.keys=r;this.errors=o}}(function(t){t[t["Any"]=0]="Any";t[t["Boolean"]=1]="Boolean";t[t["Number"]=2]="Number";t[t["String"]=3]="String"})(r.JsonPropTypes||(r.JsonPropTypes={}));function checkType(t,o){switch(o){case r.JsonPropTypes.Boolean:return typeof t==="boolean";case r.JsonPropTypes.Number:return typeof t==="number";case r.JsonPropTypes.String:return typeof t==="string"}return true}function throwIfTypeIsWrong(t,o){if(!checkType(t,o)){throw new TypeError(`Value must be ${r.JsonPropTypes[o]}`)}}function isConvertible(t){if(t&&t.prototype){if(t.prototype.toJSON&&t.prototype.fromJSON){return true}else{return isConvertible(t.prototype)}}else{return!!(t&&t.toJSON&&t.fromJSON)}}class JsonSchemaStorage{constructor(){this.items=new Map}has(t){return this.items.has(t)||!!this.findParentSchema(t)}get(t){const r=this.items.get(t)||this.findParentSchema(t);if(!r){throw new Error("Cannot get schema for current target")}return r}create(t){const r={names:{}};const o=this.findParentSchema(t);if(o){Object.assign(r,o);r.names={};for(const t in o.names){r.names[t]=Object.assign({},o.names[t])}}r.target=t;return r}set(t,r){this.items.set(t,r);return this}findParentSchema(t){const r=t.__proto__;if(r){const t=this.items.get(r);return t||this.findParentSchema(r)}return null}}const o="default";const i=new JsonSchemaStorage;class PatternValidation{constructor(t){this.pattern=new RegExp(t)}validate(t){const r=new RegExp(this.pattern.source,this.pattern.flags);if(typeof t!=="string"){throw new ValidationError("Incoming value must be string")}if(!r.exec(t)){throw new ValidationError(`Value doesn't match to pattern '${r.toString()}'`)}}}class InclusiveValidation{constructor(t=Number.MIN_VALUE,r=Number.MAX_VALUE){this.min=t;this.max=r}validate(t){throwIfTypeIsWrong(t,r.JsonPropTypes.Number);if(!(this.min<=t&&t<=this.max)){const t=this.min===Number.MIN_VALUE?"MIN":this.min;const r=this.max===Number.MAX_VALUE?"MAX":this.max;throw new ValidationError(`Value doesn't match to diapason [${t},${r}]`)}}}class ExclusiveValidation{constructor(t=Number.MIN_VALUE,r=Number.MAX_VALUE){this.min=t;this.max=r}validate(t){throwIfTypeIsWrong(t,r.JsonPropTypes.Number);if(!(this.min<t&&t<this.max)){const t=this.min===Number.MIN_VALUE?"MIN":this.min;const r=this.max===Number.MAX_VALUE?"MAX":this.max;throw new ValidationError(`Value doesn't match to diapason (${t},${r})`)}}}class LengthValidation{constructor(t,r,o){this.length=t;this.minLength=r;this.maxLength=o}validate(t){if(this.length!==undefined){if(t.length!==this.length){throw new ValidationError(`Value length must be exactly ${this.length}.`)}return}if(this.minLength!==undefined){if(t.length<this.minLength){throw new ValidationError(`Value length must be more than ${this.minLength}.`)}}if(this.maxLength!==undefined){if(t.length>this.maxLength){throw new ValidationError(`Value length must be less than ${this.maxLength}.`)}}}}class EnumerationValidation{constructor(t){this.enumeration=t}validate(t){throwIfTypeIsWrong(t,r.JsonPropTypes.String);if(!this.enumeration.includes(t)){throw new ValidationError(`Value must be one of ${this.enumeration.map((t=>`'${t}'`)).join(", ")}`)}}}class JsonTransform{static checkValues(t,r){const o=Array.isArray(t)?t:[t];for(const i of o){for(const o of r.validations){if(o instanceof LengthValidation&&r.repeated){o.validate(t)}else{o.validate(i)}}}}static checkTypes(t,r){if(r.repeated&&!Array.isArray(t)){throw new TypeError("Value must be Array")}if(typeof r.type==="number"){const o=Array.isArray(t)?t:[t];for(const t of o){throwIfTypeIsWrong(t,r.type)}}}static getSchemaByName(t,r=o){return{...t.names[o],...t.names[r]}}}class JsonSerializer extends JsonTransform{static serialize(t,r,o,i){const a=this.toJSON(t,r);return JSON.stringify(a,o,i)}static toJSON(t,r={}){let a;let c=r.targetSchema;const l=r.schemaName||o;if(isConvertible(t)){return t.toJSON()}if(Array.isArray(t)){a=[];for(const o of t){a.push(this.toJSON(o,r))}}else if(typeof t==="object"){if(c&&!i.has(c)){throw new JsonError("Cannot get schema for `targetSchema` param")}c=c||t.constructor;if(i.has(c)){const r=i.get(c);a={};const o=this.getSchemaByName(r,l);for(const i in o){try{const r=o[i];const u=t[i];let h;if(r.optional&&u===undefined||r.defaultValue!==undefined&&u===r.defaultValue){continue}if(!r.optional&&u===undefined){throw new SerializerError(c.name,`Property '${i}' is required.`)}if(typeof r.type==="number"){if(r.converter){if(r.repeated){h=u.map((o=>r.converter.toJSON(o,t)))}else{h=r.converter.toJSON(u,t)}}else{h=u}}else{if(r.repeated){h=u.map((t=>this.toJSON(t,{schemaName:l})))}else{h=this.toJSON(u,{schemaName:l})}}this.checkTypes(h,r);this.checkValues(h,r);a[r.name||i]=h}catch(t){if(t instanceof SerializerError){throw t}else{throw new SerializerError(r.target.name,`Property '${i}' is wrong. ${t.message}`,t)}}}}else{a={};for(const r in t){a[r]=this.toJSON(t[r],{schemaName:l})}}}else{a=t}return a}}class JsonParser extends JsonTransform{static parse(t,r){const o=JSON.parse(t);return this.fromJSON(o,r)}static fromJSON(t,r){const a=r.targetSchema;const c=r.schemaName||o;const l=new a;if(isConvertible(l)){return l.fromJSON(t)}const u=i.get(a);const h=this.getSchemaByName(u,c);const y={};if(r.strictProperty&&!Array.isArray(t)){JsonParser.checkStrictProperty(t,h,u)}for(const o in h){try{const i=h[o];const a=i.name||o;const y=t[a];if(y===undefined&&(i.optional||i.defaultValue!==undefined)){continue}if(!i.optional&&y===undefined){throw new ParserError(u,`Property '${a}' is required.`)}this.checkTypes(y,i);this.checkValues(y,i);if(typeof i.type==="number"){if(i.converter){if(i.repeated){l[o]=y.map((t=>i.converter.fromJSON(t,l)))}else{l[o]=i.converter.fromJSON(y,l)}}else{l[o]=y}}else{const t={...r,targetSchema:i.type,schemaName:c};if(i.repeated){l[o]=y.map((r=>this.fromJSON(r,t)))}else{l[o]=this.fromJSON(y,t)}}}catch(t){if(!(t instanceof ParserError)){t=new ParserError(u,`Property '${o}' is wrong. ${t.message}`,t)}if(r.strictAllKeys){y[o]=t}else{throw t}}}const p=Object.keys(y);if(p.length){throw new KeyError(u,p,y)}return l}static checkStrictProperty(t,r,o){const i=Object.keys(t);const a=Object.keys(r);const c=[];for(const t of i){if(a.indexOf(t)===-1){c.push(t)}}if(c.length){throw new KeyError(o,c)}}}function getValidations(t){const o=[];if(t.pattern){o.push(new PatternValidation(t.pattern))}if(t.type===r.JsonPropTypes.Number||t.type===r.JsonPropTypes.Any){if(t.minInclusive!==undefined||t.maxInclusive!==undefined){o.push(new InclusiveValidation(t.minInclusive,t.maxInclusive))}if(t.minExclusive!==undefined||t.maxExclusive!==undefined){o.push(new ExclusiveValidation(t.minExclusive,t.maxExclusive))}if(t.enumeration!==undefined){o.push(new EnumerationValidation(t.enumeration))}}if(t.type===r.JsonPropTypes.String||t.repeated||t.type===r.JsonPropTypes.Any){if(t.length!==undefined||t.minLength!==undefined||t.maxLength!==undefined){o.push(new LengthValidation(t.length,t.minLength,t.maxLength))}}return o}const JsonProp=(t={})=>(a,c)=>{const l=`Cannot set type for ${c} property of ${a.constructor.name} schema`;let u;if(!i.has(a.constructor)){u=i.create(a.constructor);i.set(a.constructor,u)}else{u=i.get(a.constructor);if(u.target!==a.constructor){u=i.create(a.constructor);i.set(a.constructor,u)}}const h={type:r.JsonPropTypes.Any,validations:[]};const y=Object.assign(h,t);y.validations=getValidations(y);if(typeof y.type!=="number"){if(!i.has(y.type)&&!isConvertible(y.type)){throw new Error(`${l}. Assigning type doesn't have schema.`)}}let p;if(Array.isArray(t.schema)){p=t.schema}else{p=[t.schema||o]}for(const t of p){if(!u.names[t]){u.names[t]={}}const r=u.names[t];r[c]=y}};r.JsonError=JsonError;r.JsonParser=JsonParser;r.JsonProp=JsonProp;r.JsonSerializer=JsonSerializer;r.KeyError=KeyError;r.ParserError=ParserError;r.SerializerError=SerializerError;r.TransformError=TransformError;r.ValidationError=ValidationError},632:t=>{
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var r;var o;var i;var a;var c;var l;var u;var h;var y;var p;var d;var g;var m;var v;var b;var w;var A;var B;var S;var k;var C;var P;var E;var K;(function(r){var o=typeof global==="object"?global:typeof self==="object"?self:typeof this==="object"?this:{};if(typeof define==="function"&&define.amd){define("tslib",["exports"],(function(t){r(createExporter(o,createExporter(t)))}))}else if(true&&typeof t.exports==="object"){r(createExporter(o,createExporter(t.exports)))}else{r(createExporter(o))}function createExporter(t,r){if(t!==o){if(typeof Object.create==="function"){Object.defineProperty(t,"__esModule",{value:true})}else{t.__esModule=true}}return function(o,i){return t[o]=r?r(o,i):i}}})((function(t){var x=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var o in r)if(Object.prototype.hasOwnProperty.call(r,o))t[o]=r[o]};r=function(t,r){if(typeof r!=="function"&&r!==null)throw new TypeError("Class extends value "+String(r)+" is not a constructor or null");x(t,r);function __(){this.constructor=t}t.prototype=r===null?Object.create(r):(__.prototype=r.prototype,new __)};o=Object.assign||function(t){for(var r,o=1,i=arguments.length;o<i;o++){r=arguments[o];for(var a in r)if(Object.prototype.hasOwnProperty.call(r,a))t[a]=r[a]}return t};i=function(t,r){var o={};for(var i in t)if(Object.prototype.hasOwnProperty.call(t,i)&&r.indexOf(i)<0)o[i]=t[i];if(t!=null&&typeof Object.getOwnPropertySymbols==="function")for(var a=0,i=Object.getOwnPropertySymbols(t);a<i.length;a++){if(r.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(t,i[a]))o[i[a]]=t[i[a]]}return o};a=function(t,r,o,i){var a=arguments.length,c=a<3?r:i===null?i=Object.getOwnPropertyDescriptor(r,o):i,l;if(typeof Reflect==="object"&&typeof Reflect.decorate==="function")c=Reflect.decorate(t,r,o,i);else for(var u=t.length-1;u>=0;u--)if(l=t[u])c=(a<3?l(c):a>3?l(r,o,c):l(r,o))||c;return a>3&&c&&Object.defineProperty(r,o,c),c};c=function(t,r){return function(o,i){r(o,i,t)}};l=function(t,r){if(typeof Reflect==="object"&&typeof Reflect.metadata==="function")return Reflect.metadata(t,r)};u=function(t,r,o,i){function adopt(t){return t instanceof o?t:new o((function(r){r(t)}))}return new(o||(o=Promise))((function(o,a){function fulfilled(t){try{step(i.next(t))}catch(t){a(t)}}function rejected(t){try{step(i["throw"](t))}catch(t){a(t)}}function step(t){t.done?o(t.value):adopt(t.value).then(fulfilled,rejected)}step((i=i.apply(t,r||[])).next())}))};h=function(t,r){var o={label:0,sent:function(){if(c[0]&1)throw c[1];return c[1]},trys:[],ops:[]},i,a,c,l;return l={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(l[Symbol.iterator]=function(){return this}),l;function verb(t){return function(r){return step([t,r])}}function step(l){if(i)throw new TypeError("Generator is already executing.");while(o)try{if(i=1,a&&(c=l[0]&2?a["return"]:l[0]?a["throw"]||((c=a["return"])&&c.call(a),0):a.next)&&!(c=c.call(a,l[1])).done)return c;if(a=0,c)l=[l[0]&2,c.value];switch(l[0]){case 0:case 1:c=l;break;case 4:o.label++;return{value:l[1],done:false};case 5:o.label++;a=l[1];l=[0];continue;case 7:l=o.ops.pop();o.trys.pop();continue;default:if(!(c=o.trys,c=c.length>0&&c[c.length-1])&&(l[0]===6||l[0]===2)){o=0;continue}if(l[0]===3&&(!c||l[1]>c[0]&&l[1]<c[3])){o.label=l[1];break}if(l[0]===6&&o.label<c[1]){o.label=c[1];c=l;break}if(c&&o.label<c[2]){o.label=c[2];o.ops.push(l);break}if(c[2])o.ops.pop();o.trys.pop();continue}l=r.call(t,o)}catch(t){l=[6,t];a=0}finally{i=c=0}if(l[0]&5)throw l[1];return{value:l[0]?l[1]:void 0,done:true}}};y=function(t,r){for(var o in t)if(o!=="default"&&!Object.prototype.hasOwnProperty.call(r,o))K(r,t,o)};K=Object.create?function(t,r,o,i){if(i===undefined)i=o;Object.defineProperty(t,i,{enumerable:true,get:function(){return r[o]}})}:function(t,r,o,i){if(i===undefined)i=o;t[i]=r[o]};p=function(t){var r=typeof Symbol==="function"&&Symbol.iterator,o=r&&t[r],i=0;if(o)return o.call(t);if(t&&typeof t.length==="number")return{next:function(){if(t&&i>=t.length)t=void 0;return{value:t&&t[i++],done:!t}}};throw new TypeError(r?"Object is not iterable.":"Symbol.iterator is not defined.")};d=function(t,r){var o=typeof Symbol==="function"&&t[Symbol.iterator];if(!o)return t;var i=o.call(t),a,c=[],l;try{while((r===void 0||r-- >0)&&!(a=i.next()).done)c.push(a.value)}catch(t){l={error:t}}finally{try{if(a&&!a.done&&(o=i["return"]))o.call(i)}finally{if(l)throw l.error}}return c};g=function(){for(var t=[],r=0;r<arguments.length;r++)t=t.concat(d(arguments[r]));return t};m=function(){for(var t=0,r=0,o=arguments.length;r<o;r++)t+=arguments[r].length;for(var i=Array(t),a=0,r=0;r<o;r++)for(var c=arguments[r],l=0,u=c.length;l<u;l++,a++)i[a]=c[l];return i};v=function(t,r){for(var o=0,i=r.length,a=t.length;o<i;o++,a++)t[a]=r[o];return t};b=function(t){return this instanceof b?(this.v=t,this):new b(t)};w=function(t,r,o){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var i=o.apply(t,r||[]),a,c=[];return a={},verb("next"),verb("throw"),verb("return"),a[Symbol.asyncIterator]=function(){return this},a;function verb(t){if(i[t])a[t]=function(r){return new Promise((function(o,i){c.push([t,r,o,i])>1||resume(t,r)}))}}function resume(t,r){try{step(i[t](r))}catch(t){settle(c[0][3],t)}}function step(t){t.value instanceof b?Promise.resolve(t.value.v).then(fulfill,reject):settle(c[0][2],t)}function fulfill(t){resume("next",t)}function reject(t){resume("throw",t)}function settle(t,r){if(t(r),c.shift(),c.length)resume(c[0][0],c[0][1])}};A=function(t){var r,o;return r={},verb("next"),verb("throw",(function(t){throw t})),verb("return"),r[Symbol.iterator]=function(){return this},r;function verb(i,a){r[i]=t[i]?function(r){return(o=!o)?{value:b(t[i](r)),done:i==="return"}:a?a(r):r}:a}};B=function(t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var r=t[Symbol.asyncIterator],o;return r?r.call(t):(t=typeof p==="function"?p(t):t[Symbol.iterator](),o={},verb("next"),verb("throw"),verb("return"),o[Symbol.asyncIterator]=function(){return this},o);function verb(r){o[r]=t[r]&&function(o){return new Promise((function(i,a){o=t[r](o),settle(i,a,o.done,o.value)}))}}function settle(t,r,o,i){Promise.resolve(i).then((function(r){t({value:r,done:o})}),r)}};S=function(t,r){if(Object.defineProperty){Object.defineProperty(t,"raw",{value:r})}else{t.raw=r}return t};var O=Object.create?function(t,r){Object.defineProperty(t,"default",{enumerable:true,value:r})}:function(t,r){t["default"]=r};k=function(t){if(t&&t.__esModule)return t;var r={};if(t!=null)for(var o in t)if(o!=="default"&&Object.prototype.hasOwnProperty.call(t,o))K(r,t,o);O(r,t);return r};C=function(t){return t&&t.__esModule?t:{default:t}};P=function(t,r,o,i){if(o==="a"&&!i)throw new TypeError("Private accessor was defined without a getter");if(typeof r==="function"?t!==r||!i:!r.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return o==="m"?i:o==="a"?i.call(t):i?i.value:r.get(t)};E=function(t,r,o,i,a){if(i==="m")throw new TypeError("Private method is not writable");if(i==="a"&&!a)throw new TypeError("Private accessor was defined without a setter");if(typeof r==="function"?t!==r||!a:!r.has(t))throw new TypeError("Cannot write private member to an object whose class did not declare it");return i==="a"?a.call(t,o):a?a.value=o:r.set(t,o),o};t("__extends",r);t("__assign",o);t("__rest",i);t("__decorate",a);t("__param",c);t("__metadata",l);t("__awaiter",u);t("__generator",h);t("__exportStar",y);t("__createBinding",K);t("__values",p);t("__read",d);t("__spread",g);t("__spreadArrays",m);t("__spreadArray",v);t("__await",b);t("__asyncGenerator",w);t("__asyncDelegator",A);t("__asyncValues",B);t("__makeTemplateObject",S);t("__importStar",k);t("__importDefault",C);t("__classPrivateFieldGet",P);t("__classPrivateFieldSet",E)}))},62:(t,r,o)=>{"use strict";Object.defineProperty(r,"__esModule",{value:true});r.fromBER=fromBER;r.compareSchema=compareSchema;r.verifySchema=verifySchema;r.fromJSON=fromJSON;r.RawData=r.Repeated=r.Any=r.Choice=r.TIME=r.Duration=r.DateTime=r.TimeOfDay=r.DATE=r.GeneralizedTime=r.UTCTime=r.CharacterString=r.GeneralString=r.VisibleString=r.GraphicString=r.IA5String=r.VideotexString=r.TeletexString=r.PrintableString=r.NumericString=r.UniversalString=r.BmpString=r.RelativeObjectIdentifier=r.Utf8String=r.ObjectIdentifier=r.Enumerated=r.Integer=r.BitString=r.OctetString=r.Null=r.Set=r.Sequence=r.Boolean=r.EndOfContent=r.Constructed=r.Primitive=r.BaseBlock=r.ValueBlock=r.HexBlock=void 0;var i=o(911);function _createForOfIteratorHelper(t,r){var o;if(typeof Symbol==="undefined"||t[Symbol.iterator]==null){if(Array.isArray(t)||(o=_unsupportedIterableToArray(t))||r&&t&&typeof t.length==="number"){if(o)t=o;var i=0;var a=function F(){};return{s:a,n:function n(){if(i>=t.length)return{done:true};return{done:false,value:t[i++]}},e:function e(t){throw t},f:a}}throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")}var c=true,l=false,u;return{s:function s(){o=t[Symbol.iterator]()},n:function n(){var t=o.next();c=t.done;return t},e:function e(t){l=true;u=t},f:function f(){try{if(!c&&o.return!=null)o.return()}finally{if(l)throw u}}}}function _unsupportedIterableToArray(t,r){if(!t)return;if(typeof t==="string")return _arrayLikeToArray(t,r);var o=Object.prototype.toString.call(t).slice(8,-1);if(o==="Object"&&t.constructor)o=t.constructor.name;if(o==="Map"||o==="Set")return Array.from(t);if(o==="Arguments"||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(o))return _arrayLikeToArray(t,r)}function _arrayLikeToArray(t,r){if(r==null||r>t.length)r=t.length;for(var o=0,i=new Array(r);o<r;o++)i[o]=t[o];return i}const a=[new Uint8Array([1])];const c="0123456789";class LocalBaseBlock{constructor(t={}){this.blockLength=(0,i.getParametersValue)(t,"blockLength",0);this.error=(0,i.getParametersValue)(t,"error","");this.warnings=(0,i.getParametersValue)(t,"warnings",[]);if("valueBeforeDecode"in t)this.valueBeforeDecode=t.valueBeforeDecode.slice(0);else this.valueBeforeDecode=new ArrayBuffer(0)}static blockName(){return"baseBlock"}toJSON(){return{blockName:this.constructor.blockName(),blockLength:this.blockLength,error:this.error,warnings:this.warnings,valueBeforeDecode:(0,i.bufferToHexCodes)(this.valueBeforeDecode,0,this.valueBeforeDecode.byteLength)}}}const HexBlock=t=>class LocalHexBlockMixin extends t{constructor(t={}){super(t);this.isHexOnly=(0,i.getParametersValue)(t,"isHexOnly",false);if("valueHex"in t)this.valueHex=t.valueHex.slice(0);else this.valueHex=new ArrayBuffer(0)}static blockName(){return"hexBlock"}fromBER(t,r,o){if((0,i.checkBufferParams)(this,t,r,o)===false)return-1;const a=new Uint8Array(t,r,o);if(a.length===0){this.warnings.push("Zero buffer length");return r}this.valueHex=t.slice(r,r+o);this.blockLength=o;return r+o}toBER(t=false){if(this.isHexOnly!==true){this.error='Flag "isHexOnly" is not set, abort';return new ArrayBuffer(0)}if(t===true)return new ArrayBuffer(this.valueHex.byteLength);return this.valueHex.slice(0)}toJSON(){let t={};try{t=super.toJSON()}catch(t){}t.blockName=this.constructor.blockName();t.isHexOnly=this.isHexOnly;t.valueHex=(0,i.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength);return t}};r.HexBlock=HexBlock;class LocalIdentificationBlock extends(HexBlock(LocalBaseBlock)){constructor(t={}){super();if("idBlock"in t){this.isHexOnly=(0,i.getParametersValue)(t.idBlock,"isHexOnly",false);this.valueHex=(0,i.getParametersValue)(t.idBlock,"valueHex",new ArrayBuffer(0));this.tagClass=(0,i.getParametersValue)(t.idBlock,"tagClass",-1);this.tagNumber=(0,i.getParametersValue)(t.idBlock,"tagNumber",-1);this.isConstructed=(0,i.getParametersValue)(t.idBlock,"isConstructed",false)}else{this.tagClass=-1;this.tagNumber=-1;this.isConstructed=false}}static blockName(){return"identificationBlock"}toBER(t=false){let r=0;let o;let a;switch(this.tagClass){case 1:r|=0;break;case 2:r|=64;break;case 3:r|=128;break;case 4:r|=192;break;default:this.error="Unknown tag class";return new ArrayBuffer(0)}if(this.isConstructed)r|=32;if(this.tagNumber<31&&!this.isHexOnly){o=new ArrayBuffer(1);a=new Uint8Array(o);if(!t){let t=this.tagNumber;t&=31;r|=t;a[0]=r}return o}if(this.isHexOnly===false){const c=(0,i.utilToBase)(this.tagNumber,7);const l=new Uint8Array(c);const u=c.byteLength;o=new ArrayBuffer(u+1);a=new Uint8Array(o);a[0]=r|31;if(!t){for(let t=0;t<u-1;t++)a[t+1]=l[t]|128;a[u]=l[u-1]}return o}o=new ArrayBuffer(this.valueHex.byteLength+1);a=new Uint8Array(o);a[0]=r|31;if(t===false){const t=new Uint8Array(this.valueHex);for(let r=0;r<t.length-1;r++)a[r+1]=t[r]|128;a[this.valueHex.byteLength]=t[t.length-1]}return o}fromBER(t,r,o){if((0,i.checkBufferParams)(this,t,r,o)===false)return-1;const a=new Uint8Array(t,r,o);if(a.length===0){this.error="Zero buffer length";return-1}const c=a[0]&192;switch(c){case 0:this.tagClass=1;break;case 64:this.tagClass=2;break;case 128:this.tagClass=3;break;case 192:this.tagClass=4;break;default:this.error="Unknown tag class";return-1}this.isConstructed=(a[0]&32)===32;this.isHexOnly=false;const l=a[0]&31;if(l!==31){this.tagNumber=l;this.blockLength=1}else{let t=1;this.valueHex=new ArrayBuffer(255);let r=255;let o=new Uint8Array(this.valueHex);while(a[t]&128){o[t-1]=a[t]&127;t++;if(t>=a.length){this.error="End of input reached before message was fully decoded";return-1}if(t===r){r+=255;const t=new ArrayBuffer(r);const i=new Uint8Array(t);for(let t=0;t<o.length;t++)i[t]=o[t];this.valueHex=new ArrayBuffer(r);o=new Uint8Array(this.valueHex)}}this.blockLength=t+1;o[t-1]=a[t]&127;const c=new ArrayBuffer(t);const l=new Uint8Array(c);for(let r=0;r<t;r++)l[r]=o[r];this.valueHex=new ArrayBuffer(t);o=new Uint8Array(this.valueHex);o.set(l);if(this.blockLength<=9)this.tagNumber=(0,i.utilFromBase)(o,7);else{this.isHexOnly=true;this.warnings.push("Tag too long, represented as hex-coded")}}if(this.tagClass===1&&this.isConstructed){switch(this.tagNumber){case 1:case 2:case 5:case 6:case 9:case 13:case 14:case 23:case 24:case 31:case 32:case 33:case 34:this.error="Constructed encoding used for primitive type";return-1;default:}}return r+this.blockLength}toJSON(){let t={};try{t=super.toJSON()}catch(t){}t.blockName=this.constructor.blockName();t.tagClass=this.tagClass;t.tagNumber=this.tagNumber;t.isConstructed=this.isConstructed;return t}}class LocalLengthBlock extends LocalBaseBlock{constructor(t={}){super();if("lenBlock"in t){this.isIndefiniteForm=(0,i.getParametersValue)(t.lenBlock,"isIndefiniteForm",false);this.longFormUsed=(0,i.getParametersValue)(t.lenBlock,"longFormUsed",false);this.length=(0,i.getParametersValue)(t.lenBlock,"length",0)}else{this.isIndefiniteForm=false;this.longFormUsed=false;this.length=0}}static blockName(){return"lengthBlock"}fromBER(t,r,o){if((0,i.checkBufferParams)(this,t,r,o)===false)return-1;const a=new Uint8Array(t,r,o);if(a.length===0){this.error="Zero buffer length";return-1}if(a[0]===255){this.error="Length block 0xFF is reserved by standard";return-1}this.isIndefiniteForm=a[0]===128;if(this.isIndefiniteForm===true){this.blockLength=1;return r+this.blockLength}this.longFormUsed=!!(a[0]&128);if(this.longFormUsed===false){this.length=a[0];this.blockLength=1;return r+this.blockLength}const c=a[0]&127;if(c>8){this.error="Too big integer";return-1}if(c+1>a.length){this.error="End of input reached before message was fully decoded";return-1}const l=new Uint8Array(c);for(let t=0;t<c;t++)l[t]=a[t+1];if(l[c-1]===0)this.warnings.push("Needlessly long encoded length");this.length=(0,i.utilFromBase)(l,8);if(this.longFormUsed&&this.length<=127)this.warnings.push("Unnecessary usage of long length form");this.blockLength=c+1;return r+this.blockLength}toBER(t=false){let r;let o;if(this.length>127)this.longFormUsed=true;if(this.isIndefiniteForm){r=new ArrayBuffer(1);if(t===false){o=new Uint8Array(r);o[0]=128}return r}if(this.longFormUsed===true){const a=(0,i.utilToBase)(this.length,8);if(a.byteLength>127){this.error="Too big length";return new ArrayBuffer(0)}r=new ArrayBuffer(a.byteLength+1);if(t===true)return r;const c=new Uint8Array(a);o=new Uint8Array(r);o[0]=a.byteLength|128;for(let t=0;t<a.byteLength;t++)o[t+1]=c[t];return r}r=new ArrayBuffer(1);if(t===false){o=new Uint8Array(r);o[0]=this.length}return r}toJSON(){let t={};try{t=super.toJSON()}catch(t){}t.blockName=this.constructor.blockName();t.isIndefiniteForm=this.isIndefiniteForm;t.longFormUsed=this.longFormUsed;t.length=this.length;return t}}class ValueBlock extends LocalBaseBlock{constructor(t={}){super(t)}static blockName(){return"valueBlock"}fromBER(t,r,o){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}toBER(t=false){throw TypeError('User need to make a specific function in a class which extends "ValueBlock"')}}r.ValueBlock=ValueBlock;class BaseBlock extends LocalBaseBlock{constructor(t={},r=ValueBlock){super(t);if("name"in t)this.name=t.name;if("optional"in t)this.optional=t.optional;if("primitiveSchema"in t)this.primitiveSchema=t.primitiveSchema;this.idBlock=new LocalIdentificationBlock(t);this.lenBlock=new LocalLengthBlock(t);this.valueBlock=new r(t)}static blockName(){return"BaseBlock"}fromBER(t,r,o){const i=this.valueBlock.fromBER(t,r,this.lenBlock.isIndefiniteForm===true?o:this.lenBlock.length);if(i===-1){this.error=this.valueBlock.error;return i}if(this.idBlock.error.length===0)this.blockLength+=this.idBlock.blockLength;if(this.lenBlock.error.length===0)this.blockLength+=this.lenBlock.blockLength;if(this.valueBlock.error.length===0)this.blockLength+=this.valueBlock.blockLength;return i}toBER(t=false){let r;const o=this.idBlock.toBER(t);const a=this.valueBlock.toBER(true);this.lenBlock.length=a.byteLength;const c=this.lenBlock.toBER(t);r=(0,i.utilConcatBuf)(o,c);let l;if(t===false)l=this.valueBlock.toBER(t);else l=new ArrayBuffer(this.lenBlock.length);r=(0,i.utilConcatBuf)(r,l);if(this.lenBlock.isIndefiniteForm===true){const o=new ArrayBuffer(2);if(t===false){const t=new Uint8Array(o);t[0]=0;t[1]=0}r=(0,i.utilConcatBuf)(r,o)}return r}toJSON(){let t={};try{t=super.toJSON()}catch(t){}t.idBlock=this.idBlock.toJSON();t.lenBlock=this.lenBlock.toJSON();t.valueBlock=this.valueBlock.toJSON();if("name"in this)t.name=this.name;if("optional"in this)t.optional=this.optional;if("primitiveSchema"in this)t.primitiveSchema=this.primitiveSchema.toJSON();return t}toString(){return`${this.constructor.blockName()} : ${(0,i.bufferToHexCodes)(this.valueBlock.valueHex)}`}}r.BaseBlock=BaseBlock;class LocalPrimitiveValueBlock extends ValueBlock{constructor(t={}){super(t);if("valueHex"in t)this.valueHex=t.valueHex.slice(0);else this.valueHex=new ArrayBuffer(0);this.isHexOnly=(0,i.getParametersValue)(t,"isHexOnly",true)}fromBER(t,r,o){if((0,i.checkBufferParams)(this,t,r,o)===false)return-1;const a=new Uint8Array(t,r,o);if(a.length===0){this.warnings.push("Zero buffer length");return r}this.valueHex=new ArrayBuffer(a.length);const c=new Uint8Array(this.valueHex);for(let t=0;t<a.length;t++)c[t]=a[t];this.blockLength=o;return r+o}toBER(t=false){return this.valueHex.slice(0)}static blockName(){return"PrimitiveValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(t){}t.valueHex=(0,i.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength);t.isHexOnly=this.isHexOnly;return t}}class Primitive extends BaseBlock{constructor(t={}){super(t,LocalPrimitiveValueBlock);this.idBlock.isConstructed=false}static blockName(){return"PRIMITIVE"}}r.Primitive=Primitive;class LocalConstructedValueBlock extends ValueBlock{constructor(t={}){super(t);this.value=(0,i.getParametersValue)(t,"value",[]);this.isIndefiniteForm=(0,i.getParametersValue)(t,"isIndefiniteForm",false)}fromBER(t,r,o){const a=r;const c=o;if((0,i.checkBufferParams)(this,t,r,o)===false)return-1;const l=new Uint8Array(t,r,o);if(l.length===0){this.warnings.push("Zero buffer length");return r}function checkLen(t,r){if(t===true)return 1;return r}let u=r;while(checkLen(this.isIndefiniteForm,o)>0){const r=LocalFromBER(t,u,o);if(r.offset===-1){this.error=r.result.error;this.warnings.concat(r.result.warnings);return-1}u=r.offset;this.blockLength+=r.result.blockLength;o-=r.result.blockLength;this.value.push(r.result);if(this.isIndefiniteForm===true&&r.result.constructor.blockName()===EndOfContent.blockName())break}if(this.isIndefiniteForm===true){if(this.value[this.value.length-1].constructor.blockName()===EndOfContent.blockName())this.value.pop();else this.warnings.push("No EndOfContent block encoded")}this.valueBeforeDecode=t.slice(a,a+c);return u}toBER(t=false){let r=new ArrayBuffer(0);for(let o=0;o<this.value.length;o++){const a=this.value[o].toBER(t);r=(0,i.utilConcatBuf)(r,a)}return r}static blockName(){return"ConstructedValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(t){}t.isIndefiniteForm=this.isIndefiniteForm;t.value=[];for(let r=0;r<this.value.length;r++)t.value.push(this.value[r].toJSON());return t}}class Constructed extends BaseBlock{constructor(t={}){super(t,LocalConstructedValueBlock);this.idBlock.isConstructed=true}static blockName(){return"CONSTRUCTED"}fromBER(t,r,o){this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;const i=this.valueBlock.fromBER(t,r,this.lenBlock.isIndefiniteForm===true?o:this.lenBlock.length);if(i===-1){this.error=this.valueBlock.error;return i}if(this.idBlock.error.length===0)this.blockLength+=this.idBlock.blockLength;if(this.lenBlock.error.length===0)this.blockLength+=this.lenBlock.blockLength;if(this.valueBlock.error.length===0)this.blockLength+=this.valueBlock.blockLength;return i}toString(){const t=[];var r=_createForOfIteratorHelper(this.valueBlock.value),o;try{for(r.s();!(o=r.n()).done;){const r=o.value;t.push(r.toString().split("\n").map((t=>`  ${t}`)).join("\n"))}}catch(t){r.e(t)}finally{r.f()}const i=this.idBlock.tagClass===3?`[${this.idBlock.tagNumber}]`:this.constructor.blockName();return t.length?`${i} :\n${t.join("\n")}`:`${i} :`}}r.Constructed=Constructed;class LocalEndOfContentValueBlock extends ValueBlock{constructor(t={}){super(t)}fromBER(t,r,o){return r}toBER(t=false){return new ArrayBuffer(0)}static blockName(){return"EndOfContentValueBlock"}}class EndOfContent extends BaseBlock{constructor(t={}){super(t,LocalEndOfContentValueBlock);this.idBlock.tagClass=1;this.idBlock.tagNumber=0}static blockName(){return"EndOfContent"}}r.EndOfContent=EndOfContent;class LocalBooleanValueBlock extends ValueBlock{constructor(t={}){super(t);this.value=(0,i.getParametersValue)(t,"value",false);this.isHexOnly=(0,i.getParametersValue)(t,"isHexOnly",false);if("valueHex"in t)this.valueHex=t.valueHex.slice(0);else{this.valueHex=new ArrayBuffer(1);if(this.value===true){const t=new Uint8Array(this.valueHex);t[0]=255}}}fromBER(t,r,o){if((0,i.checkBufferParams)(this,t,r,o)===false)return-1;const a=new Uint8Array(t,r,o);if(o>1)this.warnings.push("Boolean value encoded in more then 1 octet");this.isHexOnly=true;this.valueHex=new ArrayBuffer(a.length);const c=new Uint8Array(this.valueHex);for(let t=0;t<a.length;t++)c[t]=a[t];if(i.utilDecodeTC.call(this)!==0)this.value=true;else this.value=false;this.blockLength=o;return r+o}toBER(t=false){return this.valueHex}static blockName(){return"BooleanValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(t){}t.value=this.value;t.isHexOnly=this.isHexOnly;t.valueHex=(0,i.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength);return t}}class Boolean extends BaseBlock{constructor(t={}){super(t,LocalBooleanValueBlock);this.idBlock.tagClass=1;this.idBlock.tagNumber=1}static blockName(){return"BOOLEAN"}toString(){return`${this.constructor.blockName()} : ${this.valueBlock.value}`}}r.Boolean=Boolean;class Sequence extends Constructed{constructor(t={}){super(t);this.idBlock.tagClass=1;this.idBlock.tagNumber=16}static blockName(){return"SEQUENCE"}}r.Sequence=Sequence;class Set extends Constructed{constructor(t={}){super(t);this.idBlock.tagClass=1;this.idBlock.tagNumber=17}static blockName(){return"SET"}}r.Set=Set;class Null extends BaseBlock{constructor(t={}){super(t,LocalBaseBlock);this.idBlock.tagClass=1;this.idBlock.tagNumber=5}static blockName(){return"NULL"}fromBER(t,r,o){if(this.lenBlock.length>0)this.warnings.push("Non-zero length of value block for Null type");if(this.idBlock.error.length===0)this.blockLength+=this.idBlock.blockLength;if(this.lenBlock.error.length===0)this.blockLength+=this.lenBlock.blockLength;this.blockLength+=o;if(r+o>t.byteLength){this.error="End of input reached before message was fully decoded (inconsistent offset and length values)";return-1}return r+o}toBER(t=false){const r=new ArrayBuffer(2);if(t===true)return r;const o=new Uint8Array(r);o[0]=5;o[1]=0;return r}toString(){return`${this.constructor.blockName()}`}}r.Null=Null;class LocalOctetStringValueBlock extends(HexBlock(LocalConstructedValueBlock)){constructor(t={}){super(t);this.isConstructed=(0,i.getParametersValue)(t,"isConstructed",false)}fromBER(t,r,o){let i=0;if(this.isConstructed===true){this.isHexOnly=false;i=LocalConstructedValueBlock.prototype.fromBER.call(this,t,r,o);if(i===-1)return i;for(let t=0;t<this.value.length;t++){const r=this.value[t].constructor.blockName();if(r===EndOfContent.blockName()){if(this.isIndefiniteForm===true)break;else{this.error="EndOfContent is unexpected, OCTET STRING may consists of OCTET STRINGs only";return-1}}if(r!==OctetString.blockName()){this.error="OCTET STRING may consists of OCTET STRINGs only";return-1}}}else{this.isHexOnly=true;i=super.fromBER(t,r,o);this.blockLength=o}return i}toBER(t=false){if(this.isConstructed===true)return LocalConstructedValueBlock.prototype.toBER.call(this,t);let r=new ArrayBuffer(this.valueHex.byteLength);if(t===true)return r;if(this.valueHex.byteLength===0)return r;r=this.valueHex.slice(0);return r}static blockName(){return"OctetStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(t){}t.isConstructed=this.isConstructed;t.isHexOnly=this.isHexOnly;t.valueHex=(0,i.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength);return t}}class OctetString extends BaseBlock{constructor(t={}){super(t,LocalOctetStringValueBlock);this.idBlock.tagClass=1;this.idBlock.tagNumber=4}fromBER(t,r,o){this.valueBlock.isConstructed=this.idBlock.isConstructed;this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;if(o===0){if(this.idBlock.error.length===0)this.blockLength+=this.idBlock.blockLength;if(this.lenBlock.error.length===0)this.blockLength+=this.lenBlock.blockLength;return r}if(!this.valueBlock.isConstructed){const i=t.slice(r,r+o);try{const t=fromBER(i);if(t.offset!==-1&&t.offset===o){this.valueBlock.value=[t.result]}}catch(t){}}return super.fromBER(t,r,o)}static blockName(){return"OCTET STRING"}isEqual(t){if(t instanceof OctetString===false)return false;if(JSON.stringify(this)!==JSON.stringify(t))return false;return true}toString(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length){return Constructed.prototype.toString.call(this)}else{return`${this.constructor.blockName()} : ${(0,i.bufferToHexCodes)(this.valueBlock.valueHex)}`}}}r.OctetString=OctetString;class LocalBitStringValueBlock extends(HexBlock(LocalConstructedValueBlock)){constructor(t={}){super(t);this.unusedBits=(0,i.getParametersValue)(t,"unusedBits",0);this.isConstructed=(0,i.getParametersValue)(t,"isConstructed",false);this.blockLength=this.valueHex.byteLength}fromBER(t,r,o){if(o===0)return r;let a=-1;if(this.isConstructed===true){a=LocalConstructedValueBlock.prototype.fromBER.call(this,t,r,o);if(a===-1)return a;for(let t=0;t<this.value.length;t++){const r=this.value[t].constructor.blockName();if(r===EndOfContent.blockName()){if(this.isIndefiniteForm===true)break;else{this.error="EndOfContent is unexpected, BIT STRING may consists of BIT STRINGs only";return-1}}if(r!==BitString.blockName()){this.error="BIT STRING may consists of BIT STRINGs only";return-1}if(this.unusedBits>0&&this.value[t].valueBlock.unusedBits>0){this.error='Using of "unused bits" inside constructive BIT STRING allowed for least one only';return-1}this.unusedBits=this.value[t].valueBlock.unusedBits;if(this.unusedBits>7){this.error="Unused bits for BitString must be in range 0-7";return-1}}return a}if((0,i.checkBufferParams)(this,t,r,o)===false)return-1;const c=new Uint8Array(t,r,o);this.unusedBits=c[0];if(this.unusedBits>7){this.error="Unused bits for BitString must be in range 0-7";return-1}if(!this.unusedBits){const i=t.slice(r+1,r+o);try{const t=fromBER(i);if(t.offset!==-1&&t.offset===o-1){this.value=[t.result]}}catch(t){}}this.valueHex=new ArrayBuffer(c.length-1);const l=new Uint8Array(this.valueHex);for(let t=0;t<o-1;t++)l[t]=c[t+1];this.blockLength=c.length;return r+o}toBER(t=false){if(this.isConstructed===true)return LocalConstructedValueBlock.prototype.toBER.call(this,t);if(t===true)return new ArrayBuffer(this.valueHex.byteLength+1);if(this.valueHex.byteLength===0)return new ArrayBuffer(0);const r=new Uint8Array(this.valueHex);const o=new ArrayBuffer(this.valueHex.byteLength+1);const i=new Uint8Array(o);i[0]=this.unusedBits;for(let t=0;t<this.valueHex.byteLength;t++)i[t+1]=r[t];return o}static blockName(){return"BitStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(t){}t.unusedBits=this.unusedBits;t.isConstructed=this.isConstructed;t.isHexOnly=this.isHexOnly;t.valueHex=(0,i.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength);return t}}class BitString extends BaseBlock{constructor(t={}){super(t,LocalBitStringValueBlock);this.idBlock.tagClass=1;this.idBlock.tagNumber=3}static blockName(){return"BIT STRING"}fromBER(t,r,o){if(o===0)return r;this.valueBlock.isConstructed=this.idBlock.isConstructed;this.valueBlock.isIndefiniteForm=this.lenBlock.isIndefiniteForm;return super.fromBER(t,r,o)}isEqual(t){if(t instanceof BitString===false)return false;if(JSON.stringify(this)!==JSON.stringify(t))return false;return true}toString(){if(this.valueBlock.isConstructed||this.valueBlock.value&&this.valueBlock.value.length){return Constructed.prototype.toString.call(this)}else{const o=[];const i=new Uint8Array(this.valueBlock.valueHex);var t=_createForOfIteratorHelper(i),r;try{for(t.s();!(r=t.n()).done;){const t=r.value;o.push(t.toString(2).padStart(8,"0"))}}catch(r){t.e(r)}finally{t.f()}return`${this.constructor.blockName()} : ${o.join("")}`}}}r.BitString=BitString;class LocalIntegerValueBlock extends(HexBlock(ValueBlock)){constructor(t={}){super(t);if("value"in t)this.valueDec=t.value}set valueHex(t){this._valueHex=t.slice(0);if(t.byteLength>=4){this.warnings.push("Too big Integer for decoding, hex only");this.isHexOnly=true;this._valueDec=0}else{this.isHexOnly=false;if(t.byteLength>0)this._valueDec=i.utilDecodeTC.call(this)}}get valueHex(){return this._valueHex}set valueDec(t){this._valueDec=t;this.isHexOnly=false;this._valueHex=(0,i.utilEncodeTC)(t)}get valueDec(){return this._valueDec}fromDER(t,r,o,i=0){const a=this.fromBER(t,r,o);if(a===-1)return a;const c=new Uint8Array(this._valueHex);if(c[0]===0&&(c[1]&128)!==0){const t=new ArrayBuffer(this._valueHex.byteLength-1);const r=new Uint8Array(t);r.set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1));this._valueHex=t.slice(0)}else{if(i!==0){if(this._valueHex.byteLength<i){if(i-this._valueHex.byteLength>1)i=this._valueHex.byteLength+1;const t=new ArrayBuffer(i);const r=new Uint8Array(t);r.set(c,i-this._valueHex.byteLength);this._valueHex=t.slice(0)}}}return a}toDER(t=false){const r=new Uint8Array(this._valueHex);switch(true){case(r[0]&128)!==0:{const t=new ArrayBuffer(this._valueHex.byteLength+1);const o=new Uint8Array(t);o[0]=0;o.set(r,1);this._valueHex=t.slice(0)}break;case r[0]===0&&(r[1]&128)===0:{const t=new ArrayBuffer(this._valueHex.byteLength-1);const r=new Uint8Array(t);r.set(new Uint8Array(this._valueHex,1,this._valueHex.byteLength-1));this._valueHex=t.slice(0)}break;default:}return this.toBER(t)}fromBER(t,r,o){const i=super.fromBER(t,r,o);if(i===-1)return i;this.blockLength=o;return r+o}toBER(t=false){return this.valueHex.slice(0)}static blockName(){return"IntegerValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(t){}t.valueDec=this.valueDec;return t}toString(){function viewAdd(t,r){const o=new Uint8Array([0]);let a=new Uint8Array(t);let c=new Uint8Array(r);let l=a.slice(0);const u=l.length-1;let h=c.slice(0);const y=h.length-1;let p=0;const d=y<u?u:y;let g=0;for(let t=d;t>=0;t--,g++){switch(true){case g<h.length:p=l[u-g]+h[y-g]+o[0];break;default:p=l[u-g]+o[0]}o[0]=p/10;switch(true){case g>=l.length:l=(0,i.utilConcatView)(new Uint8Array([p%10]),l);break;default:l[u-g]=p%10}}if(o[0]>0)l=(0,i.utilConcatView)(o,l);return l.slice(0)}function power2(t){if(t>=a.length){for(let r=a.length;r<=t;r++){const t=new Uint8Array([0]);let o=a[r-1].slice(0);for(let r=o.length-1;r>=0;r--){const i=new Uint8Array([(o[r]<<1)+t[0]]);t[0]=i[0]/10;o[r]=i[0]%10}if(t[0]>0)o=(0,i.utilConcatView)(t,o);a.push(o)}}return a[t]}function viewSub(t,r){let o=0;let i=new Uint8Array(t);let a=new Uint8Array(r);let c=i.slice(0);const l=c.length-1;let u=a.slice(0);const h=u.length-1;let y;let p=0;for(let t=h;t>=0;t--,p++){y=c[l-p]-u[h-p]-o;switch(true){case y<0:o=1;c[l-p]=y+10;break;default:o=0;c[l-p]=y}}if(o>0){for(let t=l-h+1;t>=0;t--,p++){y=c[l-p]-o;if(y<0){o=1;c[l-p]=y+10}else{o=0;c[l-p]=y;break}}}return c.slice()}const t=this._valueHex.byteLength*8-1;let r=new Uint8Array(this._valueHex.byteLength*8/3);let o=0;let l;const u=new Uint8Array(this._valueHex);let h="";let y=false;for(let i=this._valueHex.byteLength-1;i>=0;i--){l=u[i];for(let i=0;i<8;i++){if((l&1)===1){switch(o){case t:r=viewSub(power2(o),r);h="-";break;default:r=viewAdd(r,power2(o))}}o++;l>>=1}}for(let t=0;t<r.length;t++){if(r[t])y=true;if(y)h+=c.charAt(r[t])}if(y===false)h+=c.charAt(0);return h}}class Integer extends BaseBlock{constructor(t={}){super(t,LocalIntegerValueBlock);this.idBlock.tagClass=1;this.idBlock.tagNumber=2}static blockName(){return"INTEGER"}isEqual(t){if(t instanceof Integer){if(this.valueBlock.isHexOnly&&t.valueBlock.isHexOnly)return(0,i.isEqualBuffer)(this.valueBlock.valueHex,t.valueBlock.valueHex);if(this.valueBlock.isHexOnly===t.valueBlock.isHexOnly)return this.valueBlock.valueDec===t.valueBlock.valueDec;return false}if(t instanceof ArrayBuffer)return(0,i.isEqualBuffer)(this.valueBlock.valueHex,t);return false}convertToDER(){const t=new Integer({valueHex:this.valueBlock.valueHex});t.valueBlock.toDER();return t}convertFromDER(){const t=this.valueBlock.valueHex.byteLength%2?this.valueBlock.valueHex.byteLength+1:this.valueBlock.valueHex.byteLength;const r=new Integer({valueHex:this.valueBlock.valueHex});r.valueBlock.fromDER(r.valueBlock.valueHex,0,r.valueBlock.valueHex.byteLength,t);return r}toString(){const t=(0,i.bufferToHexCodes)(this.valueBlock.valueHex);const r=BigInt(`0x${t}`);return`${this.constructor.blockName()} : ${r.toString()}`}}r.Integer=Integer;class Enumerated extends Integer{constructor(t={}){super(t);this.idBlock.tagClass=1;this.idBlock.tagNumber=10}static blockName(){return"ENUMERATED"}}r.Enumerated=Enumerated;class LocalSidValueBlock extends(HexBlock(LocalBaseBlock)){constructor(t={}){super(t);this.valueDec=(0,i.getParametersValue)(t,"valueDec",-1);this.isFirstSid=(0,i.getParametersValue)(t,"isFirstSid",false)}static blockName(){return"sidBlock"}fromBER(t,r,o){if(o===0)return r;if((0,i.checkBufferParams)(this,t,r,o)===false)return-1;const a=new Uint8Array(t,r,o);this.valueHex=new ArrayBuffer(o);let c=new Uint8Array(this.valueHex);for(let t=0;t<o;t++){c[t]=a[t]&127;this.blockLength++;if((a[t]&128)===0)break}const l=new ArrayBuffer(this.blockLength);const u=new Uint8Array(l);for(let t=0;t<this.blockLength;t++)u[t]=c[t];this.valueHex=l.slice(0);c=new Uint8Array(this.valueHex);if((a[this.blockLength-1]&128)!==0){this.error="End of input reached before message was fully decoded";return-1}if(c[0]===0)this.warnings.push("Needlessly long format of SID encoding");if(this.blockLength<=8)this.valueDec=(0,i.utilFromBase)(c,7);else{this.isHexOnly=true;this.warnings.push("Too big SID for decoding, hex only")}return r+this.blockLength}toBER(t=false){let r;let o;if(this.isHexOnly){if(t===true)return new ArrayBuffer(this.valueHex.byteLength);const i=new Uint8Array(this.valueHex);r=new ArrayBuffer(this.blockLength);o=new Uint8Array(r);for(let t=0;t<this.blockLength-1;t++)o[t]=i[t]|128;o[this.blockLength-1]=i[this.blockLength-1];return r}const a=(0,i.utilToBase)(this.valueDec,7);if(a.byteLength===0){this.error="Error during encoding SID value";return new ArrayBuffer(0)}r=new ArrayBuffer(a.byteLength);if(t===false){const t=new Uint8Array(a);o=new Uint8Array(r);for(let r=0;r<a.byteLength-1;r++)o[r]=t[r]|128;o[a.byteLength-1]=t[a.byteLength-1]}return r}toString(){let t="";if(this.isHexOnly===true)t=(0,i.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength);else{if(this.isFirstSid){let r=this.valueDec;if(this.valueDec<=39)t="0.";else{if(this.valueDec<=79){t="1.";r-=40}else{t="2.";r-=80}}t+=r.toString()}else t=this.valueDec.toString()}return t}toJSON(){let t={};try{t=super.toJSON()}catch(t){}t.valueDec=this.valueDec;t.isFirstSid=this.isFirstSid;return t}}class LocalObjectIdentifierValueBlock extends ValueBlock{constructor(t={}){super(t);this.fromString((0,i.getParametersValue)(t,"value",""))}fromBER(t,r,o){let i=r;while(o>0){const r=new LocalSidValueBlock;i=r.fromBER(t,i,o);if(i===-1){this.blockLength=0;this.error=r.error;return i}if(this.value.length===0)r.isFirstSid=true;this.blockLength+=r.blockLength;o-=r.blockLength;this.value.push(r)}return i}toBER(t=false){let r=new ArrayBuffer(0);for(let o=0;o<this.value.length;o++){const a=this.value[o].toBER(t);if(a.byteLength===0){this.error=this.value[o].error;return new ArrayBuffer(0)}r=(0,i.utilConcatBuf)(r,a)}return r}fromString(t){this.value=[];let r=0;let o=0;let i="";let a=false;do{o=t.indexOf(".",r);if(o===-1)i=t.substr(r);else i=t.substr(r,o-r);r=o+1;if(a){const t=this.value[0];let r=0;switch(t.valueDec){case 0:break;case 1:r=40;break;case 2:r=80;break;default:this.value=[];return false}const o=parseInt(i,10);if(isNaN(o))return true;t.valueDec=o+r;a=false}else{const t=new LocalSidValueBlock;t.valueDec=parseInt(i,10);if(isNaN(t.valueDec))return true;if(this.value.length===0){t.isFirstSid=true;a=true}this.value.push(t)}}while(o!==-1);return true}toString(){let t="";let r=false;for(let o=0;o<this.value.length;o++){r=this.value[o].isHexOnly;let i=this.value[o].toString();if(o!==0)t=`${t}.`;if(r){i=`{${i}}`;if(this.value[o].isFirstSid)t=`2.{${i} - 80}`;else t+=i}else t+=i}return t}static blockName(){return"ObjectIdentifierValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(t){}t.value=this.toString();t.sidArray=[];for(let r=0;r<this.value.length;r++)t.sidArray.push(this.value[r].toJSON());return t}}class ObjectIdentifier extends BaseBlock{constructor(t={}){super(t,LocalObjectIdentifierValueBlock);this.idBlock.tagClass=1;this.idBlock.tagNumber=6}static blockName(){return"OBJECT IDENTIFIER"}toString(){return`${this.constructor.blockName()} : ${this.valueBlock.toString()}`}}r.ObjectIdentifier=ObjectIdentifier;class LocalUtf8StringValueBlock extends(HexBlock(LocalBaseBlock)){constructor(t={}){super(t);this.isHexOnly=true;this.value=""}static blockName(){return"Utf8StringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(t){}t.value=this.value;return t}}class Utf8String extends BaseBlock{constructor(t={}){super(t,LocalUtf8StringValueBlock);if("value"in t)this.fromString(t.value);this.idBlock.tagClass=1;this.idBlock.tagNumber=12}static blockName(){return"UTF8String"}fromBER(t,r,o){const i=this.valueBlock.fromBER(t,r,this.lenBlock.isIndefiniteForm===true?o:this.lenBlock.length);if(i===-1){this.error=this.valueBlock.error;return i}this.fromBuffer(this.valueBlock.valueHex);if(this.idBlock.error.length===0)this.blockLength+=this.idBlock.blockLength;if(this.lenBlock.error.length===0)this.blockLength+=this.lenBlock.blockLength;if(this.valueBlock.error.length===0)this.blockLength+=this.valueBlock.blockLength;return i}fromBuffer(t){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(t));try{this.valueBlock.value=decodeURIComponent(escape(this.valueBlock.value))}catch(t){this.warnings.push(`Error during "decodeURIComponent": ${t}, using raw string`)}}fromString(t){const r=unescape(encodeURIComponent(t));const o=r.length;this.valueBlock.valueHex=new ArrayBuffer(o);const i=new Uint8Array(this.valueBlock.valueHex);for(let t=0;t<o;t++)i[t]=r.charCodeAt(t);this.valueBlock.value=t}toString(){return`${this.constructor.blockName()} : ${this.valueBlock.value}`}}r.Utf8String=Utf8String;class LocalRelativeSidValueBlock extends(HexBlock(LocalBaseBlock)){constructor(t={}){super(t);this.valueDec=(0,i.getParametersValue)(t,"valueDec",-1)}static blockName(){return"relativeSidBlock"}fromBER(t,r,o){if(o===0)return r;if((0,i.checkBufferParams)(this,t,r,o)===false)return-1;const a=new Uint8Array(t,r,o);this.valueHex=new ArrayBuffer(o);let c=new Uint8Array(this.valueHex);for(let t=0;t<o;t++){c[t]=a[t]&127;this.blockLength++;if((a[t]&128)===0)break}const l=new ArrayBuffer(this.blockLength);const u=new Uint8Array(l);for(let t=0;t<this.blockLength;t++)u[t]=c[t];this.valueHex=l.slice(0);c=new Uint8Array(this.valueHex);if((a[this.blockLength-1]&128)!==0){this.error="End of input reached before message was fully decoded";return-1}if(c[0]===0)this.warnings.push("Needlessly long format of SID encoding");if(this.blockLength<=8)this.valueDec=(0,i.utilFromBase)(c,7);else{this.isHexOnly=true;this.warnings.push("Too big SID for decoding, hex only")}return r+this.blockLength}toBER(t=false){let r;let o;if(this.isHexOnly){if(t===true)return new ArrayBuffer(this.valueHex.byteLength);const i=new Uint8Array(this.valueHex);r=new ArrayBuffer(this.blockLength);o=new Uint8Array(r);for(let t=0;t<this.blockLength-1;t++)o[t]=i[t]|128;o[this.blockLength-1]=i[this.blockLength-1];return r}const a=(0,i.utilToBase)(this.valueDec,7);if(a.byteLength===0){this.error="Error during encoding SID value";return new ArrayBuffer(0)}r=new ArrayBuffer(a.byteLength);if(t===false){const t=new Uint8Array(a);o=new Uint8Array(r);for(let r=0;r<a.byteLength-1;r++)o[r]=t[r]|128;o[a.byteLength-1]=t[a.byteLength-1]}return r}toString(){let t="";if(this.isHexOnly===true)t=(0,i.bufferToHexCodes)(this.valueHex,0,this.valueHex.byteLength);else{t=this.valueDec.toString()}return t}toJSON(){let t={};try{t=super.toJSON()}catch(t){}t.valueDec=this.valueDec;return t}}class LocalRelativeObjectIdentifierValueBlock extends ValueBlock{constructor(t={}){super(t);this.fromString((0,i.getParametersValue)(t,"value",""))}fromBER(t,r,o){let i=r;while(o>0){const r=new LocalRelativeSidValueBlock;i=r.fromBER(t,i,o);if(i===-1){this.blockLength=0;this.error=r.error;return i}this.blockLength+=r.blockLength;o-=r.blockLength;this.value.push(r)}return i}toBER(t=false){let r=new ArrayBuffer(0);for(let o=0;o<this.value.length;o++){const a=this.value[o].toBER(t);if(a.byteLength===0){this.error=this.value[o].error;return new ArrayBuffer(0)}r=(0,i.utilConcatBuf)(r,a)}return r}fromString(t){this.value=[];let r=0;let o=0;let i="";do{o=t.indexOf(".",r);if(o===-1)i=t.substr(r);else i=t.substr(r,o-r);r=o+1;const a=new LocalRelativeSidValueBlock;a.valueDec=parseInt(i,10);if(isNaN(a.valueDec))return true;this.value.push(a)}while(o!==-1);return true}toString(){let t="";let r=false;for(let o=0;o<this.value.length;o++){r=this.value[o].isHexOnly;let i=this.value[o].toString();if(o!==0)t=`${t}.`;if(r){i=`{${i}}`;t+=i}else t+=i}return t}static blockName(){return"RelativeObjectIdentifierValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(t){}t.value=this.toString();t.sidArray=[];for(let r=0;r<this.value.length;r++)t.sidArray.push(this.value[r].toJSON());return t}}class RelativeObjectIdentifier extends BaseBlock{constructor(t={}){super(t,LocalRelativeObjectIdentifierValueBlock);this.idBlock.tagClass=1;this.idBlock.tagNumber=13}static blockName(){return"RelativeObjectIdentifier"}}r.RelativeObjectIdentifier=RelativeObjectIdentifier;class LocalBmpStringValueBlock extends(HexBlock(LocalBaseBlock)){constructor(t={}){super(t);this.isHexOnly=true;this.value=""}static blockName(){return"BmpStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(t){}t.value=this.value;return t}}class BmpString extends BaseBlock{constructor(t={}){super(t,LocalBmpStringValueBlock);if("value"in t)this.fromString(t.value);this.idBlock.tagClass=1;this.idBlock.tagNumber=30}static blockName(){return"BMPString"}fromBER(t,r,o){const i=this.valueBlock.fromBER(t,r,this.lenBlock.isIndefiniteForm===true?o:this.lenBlock.length);if(i===-1){this.error=this.valueBlock.error;return i}this.fromBuffer(this.valueBlock.valueHex);if(this.idBlock.error.length===0)this.blockLength+=this.idBlock.blockLength;if(this.lenBlock.error.length===0)this.blockLength+=this.lenBlock.blockLength;if(this.valueBlock.error.length===0)this.blockLength+=this.valueBlock.blockLength;return i}fromBuffer(t){const r=t.slice(0);const o=new Uint8Array(r);for(let t=0;t<o.length;t+=2){const r=o[t];o[t]=o[t+1];o[t+1]=r}this.valueBlock.value=String.fromCharCode.apply(null,new Uint16Array(r))}fromString(t){const r=t.length;this.valueBlock.valueHex=new ArrayBuffer(r*2);const o=new Uint8Array(this.valueBlock.valueHex);for(let a=0;a<r;a++){const r=(0,i.utilToBase)(t.charCodeAt(a),8);const c=new Uint8Array(r);if(c.length>2)continue;const l=2-c.length;for(let t=c.length-1;t>=0;t--)o[a*2+t+l]=c[t]}this.valueBlock.value=t}toString(){return`${this.constructor.blockName()} : ${this.valueBlock.value}`}}r.BmpString=BmpString;class LocalUniversalStringValueBlock extends(HexBlock(LocalBaseBlock)){constructor(t={}){super(t);this.isHexOnly=true;this.value=""}static blockName(){return"UniversalStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(t){}t.value=this.value;return t}}class UniversalString extends BaseBlock{constructor(t={}){super(t,LocalUniversalStringValueBlock);if("value"in t)this.fromString(t.value);this.idBlock.tagClass=1;this.idBlock.tagNumber=28}static blockName(){return"UniversalString"}fromBER(t,r,o){const i=this.valueBlock.fromBER(t,r,this.lenBlock.isIndefiniteForm===true?o:this.lenBlock.length);if(i===-1){this.error=this.valueBlock.error;return i}this.fromBuffer(this.valueBlock.valueHex);if(this.idBlock.error.length===0)this.blockLength+=this.idBlock.blockLength;if(this.lenBlock.error.length===0)this.blockLength+=this.lenBlock.blockLength;if(this.valueBlock.error.length===0)this.blockLength+=this.valueBlock.blockLength;return i}fromBuffer(t){const r=t.slice(0);const o=new Uint8Array(r);for(let t=0;t<o.length;t+=4){o[t]=o[t+3];o[t+1]=o[t+2];o[t+2]=0;o[t+3]=0}this.valueBlock.value=String.fromCharCode.apply(null,new Uint32Array(r))}fromString(t){const r=t.length;this.valueBlock.valueHex=new ArrayBuffer(r*4);const o=new Uint8Array(this.valueBlock.valueHex);for(let a=0;a<r;a++){const r=(0,i.utilToBase)(t.charCodeAt(a),8);const c=new Uint8Array(r);if(c.length>4)continue;const l=4-c.length;for(let t=c.length-1;t>=0;t--)o[a*4+t+l]=c[t]}this.valueBlock.value=t}toString(){return`${this.constructor.blockName()} : ${this.valueBlock.value}`}}r.UniversalString=UniversalString;class LocalSimpleStringValueBlock extends(HexBlock(LocalBaseBlock)){constructor(t={}){super(t);this.value="";this.isHexOnly=true}static blockName(){return"SimpleStringValueBlock"}toJSON(){let t={};try{t=super.toJSON()}catch(t){}t.value=this.value;return t}}class LocalSimpleStringBlock extends BaseBlock{constructor(t={}){super(t,LocalSimpleStringValueBlock);if("value"in t)this.fromString(t.value)}static blockName(){return"SIMPLESTRING"}fromBER(t,r,o){const i=this.valueBlock.fromBER(t,r,this.lenBlock.isIndefiniteForm===true?o:this.lenBlock.length);if(i===-1){this.error=this.valueBlock.error;return i}this.fromBuffer(this.valueBlock.valueHex);if(this.idBlock.error.length===0)this.blockLength+=this.idBlock.blockLength;if(this.lenBlock.error.length===0)this.blockLength+=this.lenBlock.blockLength;if(this.valueBlock.error.length===0)this.blockLength+=this.valueBlock.blockLength;return i}fromBuffer(t){this.valueBlock.value=String.fromCharCode.apply(null,new Uint8Array(t))}fromString(t){const r=t.length;this.valueBlock.valueHex=new ArrayBuffer(r);const o=new Uint8Array(this.valueBlock.valueHex);for(let i=0;i<r;i++)o[i]=t.charCodeAt(i);this.valueBlock.value=t}toString(){return`${this.constructor.blockName()} : ${this.valueBlock.value}`}}class NumericString extends LocalSimpleStringBlock{constructor(t={}){super(t);this.idBlock.tagClass=1;this.idBlock.tagNumber=18}static blockName(){return"NumericString"}}r.NumericString=NumericString;class PrintableString extends LocalSimpleStringBlock{constructor(t={}){super(t);this.idBlock.tagClass=1;this.idBlock.tagNumber=19}static blockName(){return"PrintableString"}}r.PrintableString=PrintableString;class TeletexString extends LocalSimpleStringBlock{constructor(t={}){super(t);this.idBlock.tagClass=1;this.idBlock.tagNumber=20}static blockName(){return"TeletexString"}}r.TeletexString=TeletexString;class VideotexString extends LocalSimpleStringBlock{constructor(t={}){super(t);this.idBlock.tagClass=1;this.idBlock.tagNumber=21}static blockName(){return"VideotexString"}}r.VideotexString=VideotexString;class IA5String extends LocalSimpleStringBlock{constructor(t={}){super(t);this.idBlock.tagClass=1;this.idBlock.tagNumber=22}static blockName(){return"IA5String"}}r.IA5String=IA5String;class GraphicString extends LocalSimpleStringBlock{constructor(t={}){super(t);this.idBlock.tagClass=1;this.idBlock.tagNumber=25}static blockName(){return"GraphicString"}}r.GraphicString=GraphicString;class VisibleString extends LocalSimpleStringBlock{constructor(t={}){super(t);this.idBlock.tagClass=1;this.idBlock.tagNumber=26}static blockName(){return"VisibleString"}}r.VisibleString=VisibleString;class GeneralString extends LocalSimpleStringBlock{constructor(t={}){super(t);this.idBlock.tagClass=1;this.idBlock.tagNumber=27}static blockName(){return"GeneralString"}}r.GeneralString=GeneralString;class CharacterString extends LocalSimpleStringBlock{constructor(t={}){super(t);this.idBlock.tagClass=1;this.idBlock.tagNumber=29}static blockName(){return"CharacterString"}}r.CharacterString=CharacterString;class UTCTime extends VisibleString{constructor(t={}){super(t);this.year=0;this.month=0;this.day=0;this.hour=0;this.minute=0;this.second=0;if("value"in t){this.fromString(t.value);this.valueBlock.valueHex=new ArrayBuffer(t.value.length);const r=new Uint8Array(this.valueBlock.valueHex);for(let o=0;o<t.value.length;o++)r[o]=t.value.charCodeAt(o)}if("valueDate"in t){this.fromDate(t.valueDate);this.valueBlock.valueHex=this.toBuffer()}this.idBlock.tagClass=1;this.idBlock.tagNumber=23}fromBER(t,r,o){const i=this.valueBlock.fromBER(t,r,this.lenBlock.isIndefiniteForm===true?o:this.lenBlock.length);if(i===-1){this.error=this.valueBlock.error;return i}this.fromBuffer(this.valueBlock.valueHex);if(this.idBlock.error.length===0)this.blockLength+=this.idBlock.blockLength;if(this.lenBlock.error.length===0)this.blockLength+=this.lenBlock.blockLength;if(this.valueBlock.error.length===0)this.blockLength+=this.valueBlock.blockLength;return i}fromBuffer(t){this.fromString(String.fromCharCode.apply(null,new Uint8Array(t)))}toBuffer(){const t=this.toString();const r=new ArrayBuffer(t.length);const o=new Uint8Array(r);for(let r=0;r<t.length;r++)o[r]=t.charCodeAt(r);return r}fromDate(t){this.year=t.getUTCFullYear();this.month=t.getUTCMonth()+1;this.day=t.getUTCDate();this.hour=t.getUTCHours();this.minute=t.getUTCMinutes();this.second=t.getUTCSeconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second))}fromString(t){const r=/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})Z/gi;const o=r.exec(t);if(o===null){this.error="Wrong input string for convertion";return}const i=parseInt(o[1],10);if(i>=50)this.year=1900+i;else this.year=2e3+i;this.month=parseInt(o[2],10);this.day=parseInt(o[3],10);this.hour=parseInt(o[4],10);this.minute=parseInt(o[5],10);this.second=parseInt(o[6],10)}toString(){const t=new Array(7);t[0]=(0,i.padNumber)(this.year<2e3?this.year-1900:this.year-2e3,2);t[1]=(0,i.padNumber)(this.month,2);t[2]=(0,i.padNumber)(this.day,2);t[3]=(0,i.padNumber)(this.hour,2);t[4]=(0,i.padNumber)(this.minute,2);t[5]=(0,i.padNumber)(this.second,2);t[6]="Z";return t.join("")}static blockName(){return"UTCTime"}toJSON(){let t={};try{t=super.toJSON()}catch(t){}t.year=this.year;t.month=this.month;t.day=this.day;t.hour=this.hour;t.minute=this.minute;t.second=this.second;return t}}r.UTCTime=UTCTime;class GeneralizedTime extends VisibleString{constructor(t={}){super(t);this.year=0;this.month=0;this.day=0;this.hour=0;this.minute=0;this.second=0;this.millisecond=0;if("value"in t){this.fromString(t.value);this.valueBlock.valueHex=new ArrayBuffer(t.value.length);const r=new Uint8Array(this.valueBlock.valueHex);for(let o=0;o<t.value.length;o++)r[o]=t.value.charCodeAt(o)}if("valueDate"in t){this.fromDate(t.valueDate);this.valueBlock.valueHex=this.toBuffer()}this.idBlock.tagClass=1;this.idBlock.tagNumber=24}fromBER(t,r,o){const i=this.valueBlock.fromBER(t,r,this.lenBlock.isIndefiniteForm===true?o:this.lenBlock.length);if(i===-1){this.error=this.valueBlock.error;return i}this.fromBuffer(this.valueBlock.valueHex);if(this.idBlock.error.length===0)this.blockLength+=this.idBlock.blockLength;if(this.lenBlock.error.length===0)this.blockLength+=this.lenBlock.blockLength;if(this.valueBlock.error.length===0)this.blockLength+=this.valueBlock.blockLength;return i}fromBuffer(t){this.fromString(String.fromCharCode.apply(null,new Uint8Array(t)))}toBuffer(){const t=this.toString();const r=new ArrayBuffer(t.length);const o=new Uint8Array(r);for(let r=0;r<t.length;r++)o[r]=t.charCodeAt(r);return r}fromDate(t){this.year=t.getUTCFullYear();this.month=t.getUTCMonth()+1;this.day=t.getUTCDate();this.hour=t.getUTCHours();this.minute=t.getUTCMinutes();this.second=t.getUTCSeconds();this.millisecond=t.getUTCMilliseconds()}toDate(){return new Date(Date.UTC(this.year,this.month-1,this.day,this.hour,this.minute,this.second,this.millisecond))}fromString(t){let r=false;let o="";let i="";let a=0;let c;let l=0;let u=0;if(t[t.length-1]==="Z"){o=t.substr(0,t.length-1);r=true}else{const r=new Number(t[t.length-1]);if(isNaN(r.valueOf()))throw new Error("Wrong input string for convertion");o=t}if(r){if(o.indexOf("+")!==-1)throw new Error("Wrong input string for convertion");if(o.indexOf("-")!==-1)throw new Error("Wrong input string for convertion")}else{let t=1;let r=o.indexOf("+");let i="";if(r===-1){r=o.indexOf("-");t=-1}if(r!==-1){i=o.substr(r+1);o=o.substr(0,r);if(i.length!==2&&i.length!==4)throw new Error("Wrong input string for convertion");let a=new Number(i.substr(0,2));if(isNaN(a.valueOf()))throw new Error("Wrong input string for convertion");l=t*a;if(i.length===4){a=new Number(i.substr(2,2));if(isNaN(a.valueOf()))throw new Error("Wrong input string for convertion");u=t*a}}}let h=o.indexOf(".");if(h===-1)h=o.indexOf(",");if(h!==-1){const t=new Number(`0${o.substr(h)}`);if(isNaN(t.valueOf()))throw new Error("Wrong input string for convertion");a=t.valueOf();i=o.substr(0,h)}else i=o;switch(true){case i.length===8:c=/(\d{4})(\d{2})(\d{2})/gi;if(h!==-1)throw new Error("Wrong input string for convertion");break;case i.length===10:c=/(\d{4})(\d{2})(\d{2})(\d{2})/gi;if(h!==-1){let t=60*a;this.minute=Math.floor(t);t=60*(t-this.minute);this.second=Math.floor(t);t=1e3*(t-this.second);this.millisecond=Math.floor(t)}break;case i.length===12:c=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})/gi;if(h!==-1){let t=60*a;this.second=Math.floor(t);t=1e3*(t-this.second);this.millisecond=Math.floor(t)}break;case i.length===14:c=/(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/gi;if(h!==-1){const t=1e3*a;this.millisecond=Math.floor(t)}break;default:throw new Error("Wrong input string for convertion")}const y=c.exec(i);if(y===null)throw new Error("Wrong input string for convertion");for(let t=1;t<y.length;t++){switch(t){case 1:this.year=parseInt(y[t],10);break;case 2:this.month=parseInt(y[t],10);break;case 3:this.day=parseInt(y[t],10);break;case 4:this.hour=parseInt(y[t],10)+l;break;case 5:this.minute=parseInt(y[t],10)+u;break;case 6:this.second=parseInt(y[t],10);break;default:throw new Error("Wrong input string for convertion")}}if(r===false){const t=new Date(this.year,this.month,this.day,this.hour,this.minute,this.second,this.millisecond);this.year=t.getUTCFullYear();this.month=t.getUTCMonth();this.day=t.getUTCDay();this.hour=t.getUTCHours();this.minute=t.getUTCMinutes();this.second=t.getUTCSeconds();this.millisecond=t.getUTCMilliseconds()}}toString(){const t=[];t.push((0,i.padNumber)(this.year,4));t.push((0,i.padNumber)(this.month,2));t.push((0,i.padNumber)(this.day,2));t.push((0,i.padNumber)(this.hour,2));t.push((0,i.padNumber)(this.minute,2));t.push((0,i.padNumber)(this.second,2));if(this.millisecond!==0){t.push(".");t.push((0,i.padNumber)(this.millisecond,3))}t.push("Z");return t.join("")}static blockName(){return"GeneralizedTime"}toJSON(){let t={};try{t=super.toJSON()}catch(t){}t.year=this.year;t.month=this.month;t.day=this.day;t.hour=this.hour;t.minute=this.minute;t.second=this.second;t.millisecond=this.millisecond;return t}}r.GeneralizedTime=GeneralizedTime;class DATE extends Utf8String{constructor(t={}){super(t);this.idBlock.tagClass=1;this.idBlock.tagNumber=31}static blockName(){return"DATE"}}r.DATE=DATE;class TimeOfDay extends Utf8String{constructor(t={}){super(t);this.idBlock.tagClass=1;this.idBlock.tagNumber=32}static blockName(){return"TimeOfDay"}}r.TimeOfDay=TimeOfDay;class DateTime extends Utf8String{constructor(t={}){super(t);this.idBlock.tagClass=1;this.idBlock.tagNumber=33}static blockName(){return"DateTime"}}r.DateTime=DateTime;class Duration extends Utf8String{constructor(t={}){super(t);this.idBlock.tagClass=1;this.idBlock.tagNumber=34}static blockName(){return"Duration"}}r.Duration=Duration;class TIME extends Utf8String{constructor(t={}){super(t);this.idBlock.tagClass=1;this.idBlock.tagNumber=14}static blockName(){return"TIME"}}r.TIME=TIME;class Choice{constructor(t={}){this.value=(0,i.getParametersValue)(t,"value",[]);this.optional=(0,i.getParametersValue)(t,"optional",false)}}r.Choice=Choice;class Any{constructor(t={}){this.name=(0,i.getParametersValue)(t,"name","");this.optional=(0,i.getParametersValue)(t,"optional",false)}}r.Any=Any;class Repeated{constructor(t={}){this.name=(0,i.getParametersValue)(t,"name","");this.optional=(0,i.getParametersValue)(t,"optional",false);this.value=(0,i.getParametersValue)(t,"value",new Any);this.local=(0,i.getParametersValue)(t,"local",false)}}r.Repeated=Repeated;class RawData{constructor(t={}){this.data=(0,i.getParametersValue)(t,"data",new ArrayBuffer(0))}fromBER(t,r,o){this.data=t.slice(r,o);return r+o}toBER(t=false){return this.data}}r.RawData=RawData;function LocalFromBER(t,r,o){const a=r;function localChangeType(t,r){if(t instanceof r)return t;const o=new r;o.idBlock=t.idBlock;o.lenBlock=t.lenBlock;o.warnings=t.warnings;o.valueBeforeDecode=t.valueBeforeDecode.slice(0);return o}let c=new BaseBlock({},Object);const l=new LocalBaseBlock;if((0,i.checkBufferParams)(l,t,r,o)===false){c.error=l.error;return{offset:-1,result:c}}const u=new Uint8Array(t,r,o);if(u.length===0){c.error="Zero buffer length";return{offset:-1,result:c}}let h=c.idBlock.fromBER(t,r,o);c.warnings.concat(c.idBlock.warnings);if(h===-1){c.error=c.idBlock.error;return{offset:-1,result:c}}r=h;o-=c.idBlock.blockLength;h=c.lenBlock.fromBER(t,r,o);c.warnings.concat(c.lenBlock.warnings);if(h===-1){c.error=c.lenBlock.error;return{offset:-1,result:c}}r=h;o-=c.lenBlock.blockLength;if(c.idBlock.isConstructed===false&&c.lenBlock.isIndefiniteForm===true){c.error="Indefinite length form used for primitive encoding form";return{offset:-1,result:c}}let y=BaseBlock;switch(c.idBlock.tagClass){case 1:if(c.idBlock.tagNumber>=37&&c.idBlock.isHexOnly===false){c.error="UNIVERSAL 37 and upper tags are reserved by ASN.1 standard";return{offset:-1,result:c}}switch(c.idBlock.tagNumber){case 0:if(c.idBlock.isConstructed===true&&c.lenBlock.length>0){c.error="Type [UNIVERSAL 0] is reserved";return{offset:-1,result:c}}y=EndOfContent;break;case 1:y=Boolean;break;case 2:y=Integer;break;case 3:y=BitString;break;case 4:y=OctetString;break;case 5:y=Null;break;case 6:y=ObjectIdentifier;break;case 10:y=Enumerated;break;case 12:y=Utf8String;break;case 13:y=RelativeObjectIdentifier;break;case 14:y=TIME;break;case 15:c.error="[UNIVERSAL 15] is reserved by ASN.1 standard";return{offset:-1,result:c};case 16:y=Sequence;break;case 17:y=Set;break;case 18:y=NumericString;break;case 19:y=PrintableString;break;case 20:y=TeletexString;break;case 21:y=VideotexString;break;case 22:y=IA5String;break;case 23:y=UTCTime;break;case 24:y=GeneralizedTime;break;case 25:y=GraphicString;break;case 26:y=VisibleString;break;case 27:y=GeneralString;break;case 28:y=UniversalString;break;case 29:y=CharacterString;break;case 30:y=BmpString;break;case 31:y=DATE;break;case 32:y=TimeOfDay;break;case 33:y=DateTime;break;case 34:y=Duration;break;default:{let t;if(c.idBlock.isConstructed===true)t=new Constructed;else t=new Primitive;t.idBlock=c.idBlock;t.lenBlock=c.lenBlock;t.warnings=c.warnings;c=t}}break;case 2:case 3:case 4:default:{if(c.idBlock.isConstructed===true)y=Constructed;else y=Primitive}}c=localChangeType(c,y);h=c.fromBER(t,r,c.lenBlock.isIndefiniteForm===true?o:c.lenBlock.length);c.valueBeforeDecode=t.slice(a,a+c.blockLength);return{offset:h,result:c}}function fromBER(t){if(t.byteLength===0){const t=new BaseBlock({},Object);t.error="Input buffer has zero length";return{offset:-1,result:t}}return LocalFromBER(t,0,t.byteLength)}function compareSchema(t,r,o){if(o instanceof Choice){const i=false;for(let i=0;i<o.value.length;i++){const a=compareSchema(t,r,o.value[i]);if(a.verified===true){return{verified:true,result:t}}}if(i===false){const t={verified:false,result:{error:"Wrong values for Choice type"}};if(o.hasOwnProperty("name"))t.name=o.name;return t}}if(o instanceof Any){if(o.hasOwnProperty("name"))t[o.name]=r;return{verified:true,result:t}}if(t instanceof Object===false){return{verified:false,result:{error:"Wrong root object"}}}if(r instanceof Object===false){return{verified:false,result:{error:"Wrong ASN.1 data"}}}if(o instanceof Object===false){return{verified:false,result:{error:"Wrong ASN.1 schema"}}}if("idBlock"in o===false){return{verified:false,result:{error:"Wrong ASN.1 schema"}}}if("fromBER"in o.idBlock===false){return{verified:false,result:{error:"Wrong ASN.1 schema"}}}if("toBER"in o.idBlock===false){return{verified:false,result:{error:"Wrong ASN.1 schema"}}}const i=o.idBlock.toBER(false);if(i.byteLength===0){return{verified:false,result:{error:"Error encoding idBlock for ASN.1 schema"}}}const a=o.idBlock.fromBER(i,0,i.byteLength);if(a===-1){return{verified:false,result:{error:"Error decoding idBlock for ASN.1 schema"}}}if(o.idBlock.hasOwnProperty("tagClass")===false){return{verified:false,result:{error:"Wrong ASN.1 schema"}}}if(o.idBlock.tagClass!==r.idBlock.tagClass){return{verified:false,result:t}}if(o.idBlock.hasOwnProperty("tagNumber")===false){return{verified:false,result:{error:"Wrong ASN.1 schema"}}}if(o.idBlock.tagNumber!==r.idBlock.tagNumber){return{verified:false,result:t}}if(o.idBlock.hasOwnProperty("isConstructed")===false){return{verified:false,result:{error:"Wrong ASN.1 schema"}}}if(o.idBlock.isConstructed!==r.idBlock.isConstructed){return{verified:false,result:t}}if("isHexOnly"in o.idBlock===false){return{verified:false,result:{error:"Wrong ASN.1 schema"}}}if(o.idBlock.isHexOnly!==r.idBlock.isHexOnly){return{verified:false,result:t}}if(o.idBlock.isHexOnly===true){if("valueHex"in o.idBlock===false){return{verified:false,result:{error:"Wrong ASN.1 schema"}}}const i=new Uint8Array(o.idBlock.valueHex);const a=new Uint8Array(r.idBlock.valueHex);if(i.length!==a.length){return{verified:false,result:t}}for(let r=0;r<i.length;r++){if(i[r]!==a[1]){return{verified:false,result:t}}}}if(o.hasOwnProperty("name")){o.name=o.name.replace(/^\s+|\s+$/g,"");if(o.name!=="")t[o.name]=r}if(o.idBlock.isConstructed===true){let i=0;let a={verified:false};let c=o.valueBlock.value.length;if(c>0){if(o.valueBlock.value[0]instanceof Repeated)c=r.valueBlock.value.length}if(c===0){return{verified:true,result:t}}if(r.valueBlock.value.length===0&&o.valueBlock.value.length!==0){let r=true;for(let t=0;t<o.valueBlock.value.length;t++)r=r&&(o.valueBlock.value[t].optional||false);if(r===true){return{verified:true,result:t}}if(o.hasOwnProperty("name")){o.name=o.name.replace(/^\s+|\s+$/g,"");if(o.name!=="")delete t[o.name]}t.error="Inconsistent object length";return{verified:false,result:t}}for(let l=0;l<c;l++){if(l-i>=r.valueBlock.value.length){if(o.valueBlock.value[l].optional===false){const r={verified:false,result:t};t.error="Inconsistent length between ASN.1 data and schema";if(o.hasOwnProperty("name")){o.name=o.name.replace(/^\s+|\s+$/g,"");if(o.name!==""){delete t[o.name];r.name=o.name}}return r}}else{if(o.valueBlock.value[0]instanceof Repeated){a=compareSchema(t,r.valueBlock.value[l],o.valueBlock.value[0].value);if(a.verified===false){if(o.valueBlock.value[0].optional===true)i++;else{if(o.hasOwnProperty("name")){o.name=o.name.replace(/^\s+|\s+$/g,"");if(o.name!=="")delete t[o.name]}return a}}if("name"in o.valueBlock.value[0]&&o.valueBlock.value[0].name.length>0){let i={};if("local"in o.valueBlock.value[0]&&o.valueBlock.value[0].local===true)i=r;else i=t;if(typeof i[o.valueBlock.value[0].name]==="undefined")i[o.valueBlock.value[0].name]=[];i[o.valueBlock.value[0].name].push(r.valueBlock.value[l])}}else{a=compareSchema(t,r.valueBlock.value[l-i],o.valueBlock.value[l]);if(a.verified===false){if(o.valueBlock.value[l].optional===true)i++;else{if(o.hasOwnProperty("name")){o.name=o.name.replace(/^\s+|\s+$/g,"");if(o.name!=="")delete t[o.name]}return a}}}}}if(a.verified===false){const r={verified:false,result:t};if(o.hasOwnProperty("name")){o.name=o.name.replace(/^\s+|\s+$/g,"");if(o.name!==""){delete t[o.name];r.name=o.name}}return r}return{verified:true,result:t}}if("primitiveSchema"in o&&"valueHex"in r.valueBlock){const i=fromBER(r.valueBlock.valueHex);if(i.offset===-1){const r={verified:false,result:i.result};if(o.hasOwnProperty("name")){o.name=o.name.replace(/^\s+|\s+$/g,"");if(o.name!==""){delete t[o.name];r.name=o.name}}return r}return compareSchema(t,i.result,o.primitiveSchema)}return{verified:true,result:t}}function verifySchema(t,r){if(r instanceof Object===false){return{verified:false,result:{error:"Wrong ASN.1 schema type"}}}const o=fromBER(t);if(o.offset===-1){return{verified:false,result:o.result}}return compareSchema(o.result,o.result,r)}function fromJSON(t){}},7:function(t,r){(function(t,o){true?o(r):0})(this,(function(t){"use strict";class BufferSourceConverter{static isArrayBuffer(t){return Object.prototype.toString.call(t)==="[object ArrayBuffer]"}static toArrayBuffer(t){const r=this.toUint8Array(t);if(r.byteOffset||r.length){return r.buffer.slice(r.byteOffset,r.byteOffset+r.length)}return r.buffer}static toUint8Array(t){return this.toView(t,Uint8Array)}static toView(t,r){if(typeof Buffer!=="undefined"&&Buffer.isBuffer(t)){return new r(t.buffer,t.byteOffset,t.byteLength)}if(this.isArrayBuffer(t)){return new r(t)}if(this.isArrayBufferView(t)){return new r(t.buffer,t.byteOffset,t.byteLength)}throw new TypeError("The provided value is not of type '(ArrayBuffer or ArrayBufferView)'")}static isBufferSource(t){return this.isArrayBufferView(t)||this.isArrayBuffer(t)}static isArrayBufferView(t){return ArrayBuffer.isView(t)||t&&this.isArrayBuffer(t.buffer)}}class Utf8Converter{static fromString(t){const r=unescape(encodeURIComponent(t));const o=new Uint8Array(r.length);for(let t=0;t<r.length;t++){o[t]=r.charCodeAt(t)}return o.buffer}static toString(t){const r=BufferSourceConverter.toUint8Array(t);let o="";for(let t=0;t<r.length;t++){o+=String.fromCharCode(r[t])}const i=decodeURIComponent(escape(o));return i}}class Utf16Converter{static toString(t,r=false){const o=BufferSourceConverter.toArrayBuffer(t);const i=new DataView(o);let a="";for(let t=0;t<o.byteLength;t+=2){const o=i.getUint16(t,r);a+=String.fromCharCode(o)}return a}static fromString(t,r=false){const o=new ArrayBuffer(t.length*2);const i=new DataView(o);for(let o=0;o<t.length;o++){i.setUint16(o*2,t.charCodeAt(o),r)}return o}}class Convert{static isHex(t){return typeof t==="string"&&/^[a-z0-9]+$/i.test(t)}static isBase64(t){return typeof t==="string"&&/^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(t)}static isBase64Url(t){return typeof t==="string"&&/^[a-zA-Z0-9-_]+$/i.test(t)}static ToString(t,r="utf8"){const o=BufferSourceConverter.toUint8Array(t);switch(r.toLowerCase()){case"utf8":return this.ToUtf8String(o);case"binary":return this.ToBinary(o);case"hex":return this.ToHex(o);case"base64":return this.ToBase64(o);case"base64url":return this.ToBase64Url(o);case"utf16le":return Utf16Converter.toString(o,true);case"utf16":case"utf16be":return Utf16Converter.toString(o);default:throw new Error(`Unknown type of encoding '${r}'`)}}static FromString(t,r="utf8"){if(!t){return new ArrayBuffer(0)}switch(r.toLowerCase()){case"utf8":return this.FromUtf8String(t);case"binary":return this.FromBinary(t);case"hex":return this.FromHex(t);case"base64":return this.FromBase64(t);case"base64url":return this.FromBase64Url(t);case"utf16le":return Utf16Converter.fromString(t,true);case"utf16":case"utf16be":return Utf16Converter.fromString(t);default:throw new Error(`Unknown type of encoding '${r}'`)}}static ToBase64(t){const r=BufferSourceConverter.toUint8Array(t);if(typeof btoa!=="undefined"){const t=this.ToString(r,"binary");return btoa(t)}else{return Buffer.from(r).toString("base64")}}static FromBase64(t){const r=this.formatString(t);if(!r){return new ArrayBuffer(0)}if(!Convert.isBase64(r)){throw new TypeError("Argument 'base64Text' is not Base64 encoded")}if(typeof atob!=="undefined"){return this.FromBinary(atob(r))}else{return new Uint8Array(Buffer.from(r,"base64")).buffer}}static FromBase64Url(t){const r=this.formatString(t);if(!r){return new ArrayBuffer(0)}if(!Convert.isBase64Url(r)){throw new TypeError("Argument 'base64url' is not Base64Url encoded")}return this.FromBase64(this.Base64Padding(r.replace(/\-/g,"+").replace(/\_/g,"/")))}static ToBase64Url(t){return this.ToBase64(t).replace(/\+/g,"-").replace(/\//g,"_").replace(/\=/g,"")}static FromUtf8String(t,r=Convert.DEFAULT_UTF8_ENCODING){switch(r){case"ascii":return this.FromBinary(t);case"utf8":return Utf8Converter.fromString(t);case"utf16":case"utf16be":return Utf16Converter.fromString(t);case"utf16le":case"usc2":return Utf16Converter.fromString(t,true);default:throw new Error(`Unknown type of encoding '${r}'`)}}static ToUtf8String(t,r=Convert.DEFAULT_UTF8_ENCODING){switch(r){case"ascii":return this.ToBinary(t);case"utf8":return Utf8Converter.toString(t);case"utf16":case"utf16be":return Utf16Converter.toString(t);case"utf16le":case"usc2":return Utf16Converter.toString(t,true);default:throw new Error(`Unknown type of encoding '${r}'`)}}static FromBinary(t){const r=t.length;const o=new Uint8Array(r);for(let i=0;i<r;i++){o[i]=t.charCodeAt(i)}return o.buffer}static ToBinary(t){const r=BufferSourceConverter.toUint8Array(t);let o="";for(let t=0;t<r.length;t++){o+=String.fromCharCode(r[t])}return o}static ToHex(t){const r=BufferSourceConverter.toUint8Array(t);const o="";const i=[];const a=r.length;for(let t=0;t<a;t++){const o=r[t].toString(16).padStart(2,"0");i.push(o)}return i.join(o)}static FromHex(t){let r=this.formatString(t);if(!r){return new ArrayBuffer(0)}if(!Convert.isHex(r)){throw new TypeError("Argument 'hexString' is not HEX encoded")}if(r.length%2){r=`0${r}`}const o=new Uint8Array(r.length/2);for(let t=0;t<r.length;t=t+2){const i=r.slice(t,t+2);o[t/2]=parseInt(i,16)}return o.buffer}static ToUtf16String(t,r=false){return Utf16Converter.toString(t,r)}static FromUtf16String(t,r=false){return Utf16Converter.fromString(t,r)}static Base64Padding(t){const r=4-t.length%4;if(r<4){for(let o=0;o<r;o++){t+="="}}return t}static formatString(t){return(t===null||t===void 0?void 0:t.replace(/[\n\r\t ]/g,""))||""}}Convert.DEFAULT_UTF8_ENCODING="utf8";function assign(t,...r){const o=arguments[0];for(let t=1;t<arguments.length;t++){const r=arguments[t];for(const t in r){o[t]=r[t]}}return o}function combine(...t){const r=t.map((t=>t.byteLength)).reduce(((t,r)=>t+r));const o=new Uint8Array(r);let i=0;t.map((t=>new Uint8Array(t))).forEach((t=>{for(const r of t){o[i++]=r}}));return o.buffer}function isEqual(t,r){if(!(t&&r)){return false}if(t.byteLength!==r.byteLength){return false}const o=new Uint8Array(t);const i=new Uint8Array(r);for(let r=0;r<t.byteLength;r++){if(o[r]!==i[r]){return false}}return true}t.BufferSourceConverter=BufferSourceConverter;t.Convert=Convert;t.assign=assign;t.combine=combine;t.isEqual=isEqual;Object.defineProperty(t,"__esModule",{value:true})}))},911:(t,r)=>{"use strict";Object.defineProperty(r,"__esModule",{value:true});r.getUTCDate=getUTCDate;r.getParametersValue=getParametersValue;r.bufferToHexCodes=bufferToHexCodes;r.checkBufferParams=checkBufferParams;r.utilFromBase=utilFromBase;r.utilToBase=utilToBase;r.utilConcatBuf=utilConcatBuf;r.utilConcatView=utilConcatView;r.utilDecodeTC=utilDecodeTC;r.utilEncodeTC=utilEncodeTC;r.isEqualBuffer=isEqualBuffer;r.padNumber=padNumber;r.toBase64=toBase64;r.fromBase64=fromBase64;r.arrayBufferToString=arrayBufferToString;r.stringToArrayBuffer=stringToArrayBuffer;r.nearestPowerOf2=nearestPowerOf2;r.clearProps=clearProps;function getUTCDate(t){return new Date(t.getTime()+t.getTimezoneOffset()*6e4)}function getParametersValue(t,r,o){if(t instanceof Object===false)return o;if(r in t)return t[r];return o}function bufferToHexCodes(t,r=0,o=t.byteLength-r,i=false){let a="";var c=true;var l=false;var u=undefined;try{for(var h=new Uint8Array(t,r,o)[Symbol.iterator](),y;!(c=(y=h.next()).done);c=true){const t=y.value;const r=t.toString(16).toUpperCase();if(r.length===1)a+="0";a+=r;if(i)a+=" "}}catch(t){l=true;u=t}finally{try{if(!c&&h.return){h.return()}}finally{if(l){throw u}}}return a.trim()}function checkBufferParams(t,r,o,i){if(r instanceof ArrayBuffer===false){t.error='Wrong parameter: inputBuffer must be "ArrayBuffer"';return false}if(r.byteLength===0){t.error="Wrong parameter: inputBuffer has zero length";return false}if(o<0){t.error="Wrong parameter: inputOffset less than zero";return false}if(i<0){t.error="Wrong parameter: inputLength less than zero";return false}if(r.byteLength-o-i<0){t.error="End of input reached before message was fully decoded (inconsistent offset and length values)";return false}return true}function utilFromBase(t,r){let o=0;if(t.length===1)return t[0];for(let i=t.length-1;i>=0;i--)o+=t[t.length-1-i]*Math.pow(2,r*i);return o}function utilToBase(t,r,o=-1){const i=o;let a=t;let c=0;let l=Math.pow(2,r);for(let o=1;o<8;o++){if(t<l){let t;if(i<0){t=new ArrayBuffer(o);c=o}else{if(i<o)return new ArrayBuffer(0);t=new ArrayBuffer(i);c=i}const l=new Uint8Array(t);for(let t=o-1;t>=0;t--){const o=Math.pow(2,t*r);l[c-t-1]=Math.floor(a/o);a-=l[c-t-1]*o}return t}l*=Math.pow(2,r)}return new ArrayBuffer(0)}function utilConcatBuf(...t){let r=0;let o=0;var i=true;var a=false;var c=undefined;try{for(var l=t[Symbol.iterator](),u;!(i=(u=l.next()).done);i=true){const t=u.value;r+=t.byteLength}}catch(t){a=true;c=t}finally{try{if(!i&&l.return){l.return()}}finally{if(a){throw c}}}const h=new ArrayBuffer(r);const y=new Uint8Array(h);var p=true;var d=false;var g=undefined;try{for(var m=t[Symbol.iterator](),v;!(p=(v=m.next()).done);p=true){const t=v.value;y.set(new Uint8Array(t),o);o+=t.byteLength}}catch(t){d=true;g=t}finally{try{if(!p&&m.return){m.return()}}finally{if(d){throw g}}}return h}function utilConcatView(...t){let r=0;let o=0;var i=true;var a=false;var c=undefined;try{for(var l=t[Symbol.iterator](),u;!(i=(u=l.next()).done);i=true){const t=u.value;r+=t.length}}catch(t){a=true;c=t}finally{try{if(!i&&l.return){l.return()}}finally{if(a){throw c}}}const h=new ArrayBuffer(r);const y=new Uint8Array(h);var p=true;var d=false;var g=undefined;try{for(var m=t[Symbol.iterator](),v;!(p=(v=m.next()).done);p=true){const t=v.value;y.set(t,o);o+=t.length}}catch(t){d=true;g=t}finally{try{if(!p&&m.return){m.return()}}finally{if(d){throw g}}}return y}function utilDecodeTC(){const t=new Uint8Array(this.valueHex);if(this.valueHex.byteLength>=2){const r=t[0]===255&&t[1]&128;const o=t[0]===0&&(t[1]&128)===0;if(r||o)this.warnings.push("Needlessly long format")}const r=new ArrayBuffer(this.valueHex.byteLength);const o=new Uint8Array(r);for(let t=0;t<this.valueHex.byteLength;t++)o[t]=0;o[0]=t[0]&128;const i=utilFromBase(o,8);const a=new ArrayBuffer(this.valueHex.byteLength);const c=new Uint8Array(a);for(let r=0;r<this.valueHex.byteLength;r++)c[r]=t[r];c[0]&=127;const l=utilFromBase(c,8);return l-i}function utilEncodeTC(t){const r=t<0?t*-1:t;let o=128;for(let i=1;i<8;i++){if(r<=o){if(t<0){const t=o-r;const a=utilToBase(t,8,i);const c=new Uint8Array(a);c[0]|=128;return a}let a=utilToBase(r,8,i);let c=new Uint8Array(a);if(c[0]&128){const t=a.slice(0);const r=new Uint8Array(t);a=new ArrayBuffer(a.byteLength+1);c=new Uint8Array(a);for(let o=0;o<t.byteLength;o++)c[o+1]=r[o];c[0]=0}return a}o*=Math.pow(2,8)}return new ArrayBuffer(0)}function isEqualBuffer(t,r){if(t.byteLength!==r.byteLength)return false;const o=new Uint8Array(t);const i=new Uint8Array(r);for(let t=0;t<o.length;t++){if(o[t]!==i[t])return false}return true}function padNumber(t,r){const o=t.toString(10);if(r<o.length)return"";const i=r-o.length;const a=new Array(i);for(let t=0;t<i;t++)a[t]="0";const c=a.join("");return c.concat(o)}const o="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";const i="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=";function toBase64(t,r=false,a=false,c=false){let l=0;let u=0;let h=0;let y="";const p=r?i:o;if(c){let r=0;for(let o=0;o<t.length;o++){if(t.charCodeAt(o)!==0){r=o;break}}t=t.slice(r)}while(l<t.length){const r=t.charCodeAt(l++);if(l>=t.length)u=1;const o=t.charCodeAt(l++);if(l>=t.length)h=1;const i=t.charCodeAt(l++);const c=r>>2;const d=(r&3)<<4|o>>4;let g=(o&15)<<2|i>>6;let m=i&63;if(u===1){g=m=64}else{if(h===1){m=64}}if(a){if(g===64)y+=`${p.charAt(c)}${p.charAt(d)}`;else{if(m===64)y+=`${p.charAt(c)}${p.charAt(d)}${p.charAt(g)}`;else y+=`${p.charAt(c)}${p.charAt(d)}${p.charAt(g)}${p.charAt(m)}`}}else y+=`${p.charAt(c)}${p.charAt(d)}${p.charAt(g)}${p.charAt(m)}`}return y}function fromBase64(t,r=false,a=false){const c=r?i:o;function indexof(t){for(let r=0;r<64;r++){if(c.charAt(r)===t)return r}return 64}function test(t){return t===64?0:t}let l=0;let u="";while(l<t.length){const r=indexof(t.charAt(l++));const o=l>=t.length?0:indexof(t.charAt(l++));const i=l>=t.length?0:indexof(t.charAt(l++));const a=l>=t.length?0:indexof(t.charAt(l++));const c=test(r)<<2|test(o)>>4;const h=(test(o)&15)<<4|test(i)>>2;const y=(test(i)&3)<<6|test(a);u+=String.fromCharCode(c);if(i!==64)u+=String.fromCharCode(h);if(a!==64)u+=String.fromCharCode(y)}if(a){const t=u.length;let r=-1;for(let o=t-1;o>=0;o--){if(u.charCodeAt(o)!==0){r=o;break}}if(r!==-1)u=u.slice(0,r+1);else u=""}return u}function arrayBufferToString(t){let r="";const o=new Uint8Array(t);var i=true;var a=false;var c=undefined;try{for(var l=o[Symbol.iterator](),u;!(i=(u=l.next()).done);i=true){const t=u.value;r+=String.fromCharCode(t)}}catch(t){a=true;c=t}finally{try{if(!i&&l.return){l.return()}}finally{if(a){throw c}}}return r}function stringToArrayBuffer(t){const r=t.length;const o=new ArrayBuffer(r);const i=new Uint8Array(o);for(let o=0;o<r;o++)i[o]=t.charCodeAt(o);return o}const a=Math.log(2);function nearestPowerOf2(t){const r=Math.log(t)/a;const o=Math.floor(r);const i=Math.round(r);return o===i?o:i}function clearProps(t,r){var o=true;var i=false;var a=undefined;try{for(var c=r[Symbol.iterator](),l;!(o=(l=c.next()).done);o=true){const r=l.value;delete t[r]}}catch(t){i=true;a=t}finally{try{if(!o&&c.return){c.return()}}finally{if(i){throw a}}}}},837:(t,r,o)=>{"use strict";Object.defineProperty(r,"__esModule",{value:true});var i=o(7);var a=o(761);var c=o(297);var l=o(628);var u=o(62);function _interopNamespace(t){if(t&&t.__esModule)return t;var r=Object.create(null);if(t){Object.keys(t).forEach((function(o){if(o!=="default"){var i=Object.getOwnPropertyDescriptor(t,o);Object.defineProperty(r,o,i.get?i:{enumerable:true,get:function(){return t[o]}})}}))}r["default"]=t;return Object.freeze(r)}var h=_interopNamespace(u);class CryptoError extends Error{}class AlgorithmError extends CryptoError{}class UnsupportedOperationError extends CryptoError{constructor(t){super(`Unsupported operation: ${t?`${t}`:""}`)}}class OperationError extends CryptoError{}class RequiredPropertyError extends CryptoError{constructor(t){super(`${t}: Missing required property`)}}class PemConverter{static toArrayBuffer(t){const r=t.replace(/-{5}(BEGIN|END) .*-{5}/g,"").replace("\r","").replace("\n","");return i.Convert.FromBase64(r)}static toUint8Array(t){const r=this.toArrayBuffer(t);return new Uint8Array(r)}static fromBufferSource(t,r){const o=i.Convert.ToBase64(t);let a;let c=0;const l=[];while(true){a=o.slice(c,c=c+64);if(a.length){l.push(a);if(a.length<64){break}}else{break}}const u=r.toUpperCase();return`-----BEGIN ${u}-----\n${l.join("\n")}\n-----END ${u}-----`}static isPEM(t){return/-----BEGIN .+-----[A-Za-z0-9+\/\+\=\s\n]+-----END .+-----/i.test(t)}static getTagName(t){if(!this.isPEM(t)){throw new Error("Bad parameter. Incoming data is not right PEM")}const r=/-----BEGIN (.+)-----/.exec(t);if(!r){throw new Error("Cannot get tag from PEM")}return r[1]}static hasTagName(t,r){const o=this.getTagName(t);return r.toLowerCase()===o.toLowerCase()}static isCertificate(t){return this.hasTagName(t,"certificate")}static isCertificateRequest(t){return this.hasTagName(t,"certificate request")}static isCRL(t){return this.hasTagName(t,"x509 crl")}static isPublicKey(t){return this.hasTagName(t,"public key")}}function isJWK(t){return typeof t==="object"&&"kty"in t}class ProviderCrypto{async digest(...t){this.checkDigest.apply(this,t);return this.onDigest.apply(this,t)}checkDigest(t,r){this.checkAlgorithmName(t)}async onDigest(t,r){throw new UnsupportedOperationError("digest")}async generateKey(...t){this.checkGenerateKey.apply(this,t);return this.onGenerateKey.apply(this,t)}checkGenerateKey(t,r,o,...i){this.checkAlgorithmName(t);this.checkGenerateKeyParams(t);if(!(o&&o.length)){throw new TypeError(`Usages cannot be empty when creating a key.`)}let a;if(Array.isArray(this.usages)){a=this.usages}else{a=this.usages.privateKey.concat(this.usages.publicKey)}this.checkKeyUsages(o,a)}checkGenerateKeyParams(t){}async onGenerateKey(t,r,o,...i){throw new UnsupportedOperationError("generateKey")}async sign(...t){this.checkSign.apply(this,t);return this.onSign.apply(this,t)}checkSign(t,r,o,...i){this.checkAlgorithmName(t);this.checkAlgorithmParams(t);this.checkCryptoKey(r,"sign")}async onSign(t,r,o,...i){throw new UnsupportedOperationError("sign")}async verify(...t){this.checkVerify.apply(this,t);return this.onVerify.apply(this,t)}checkVerify(t,r,o,i,...a){this.checkAlgorithmName(t);this.checkAlgorithmParams(t);this.checkCryptoKey(r,"verify")}async onVerify(t,r,o,i,...a){throw new UnsupportedOperationError("verify")}async encrypt(...t){this.checkEncrypt.apply(this,t);return this.onEncrypt.apply(this,t)}checkEncrypt(t,r,o,i={},...a){this.checkAlgorithmName(t);this.checkAlgorithmParams(t);this.checkCryptoKey(r,i.keyUsage?"encrypt":void 0)}async onEncrypt(t,r,o,...i){throw new UnsupportedOperationError("encrypt")}async decrypt(...t){this.checkDecrypt.apply(this,t);return this.onDecrypt.apply(this,t)}checkDecrypt(t,r,o,i={},...a){this.checkAlgorithmName(t);this.checkAlgorithmParams(t);this.checkCryptoKey(r,i.keyUsage?"decrypt":void 0)}async onDecrypt(t,r,o,...i){throw new UnsupportedOperationError("decrypt")}async deriveBits(...t){this.checkDeriveBits.apply(this,t);return this.onDeriveBits.apply(this,t)}checkDeriveBits(t,r,o,i={},...a){this.checkAlgorithmName(t);this.checkAlgorithmParams(t);this.checkCryptoKey(r,i.keyUsage?"deriveBits":void 0);if(o%8!==0){throw new OperationError("length: Is not multiple of 8")}}async onDeriveBits(t,r,o,...i){throw new UnsupportedOperationError("deriveBits")}async exportKey(...t){this.checkExportKey.apply(this,t);return this.onExportKey.apply(this,t)}checkExportKey(t,r,...o){this.checkKeyFormat(t);this.checkCryptoKey(r);if(!r.extractable){throw new CryptoError("key: Is not extractable")}}async onExportKey(t,r,...o){throw new UnsupportedOperationError("exportKey")}async importKey(...t){this.checkImportKey.apply(this,t);return this.onImportKey.apply(this,t)}checkImportKey(t,r,o,i,a,...c){this.checkKeyFormat(t);this.checkKeyData(t,r);this.checkAlgorithmName(o);this.checkImportParams(o);if(Array.isArray(this.usages)){this.checkKeyUsages(a,this.usages)}}async onImportKey(t,r,o,i,a,...c){throw new UnsupportedOperationError("importKey")}checkAlgorithmName(t){if(t.name.toLowerCase()!==this.name.toLowerCase()){throw new AlgorithmError("Unrecognized name")}}checkAlgorithmParams(t){}checkDerivedKeyParams(t){}checkKeyUsages(t,r){for(const o of t){if(r.indexOf(o)===-1){throw new TypeError("Cannot create a key using the specified key usages")}}}checkCryptoKey(t,r){this.checkAlgorithmName(t.algorithm);if(r&&t.usages.indexOf(r)===-1){throw new CryptoError(`key does not match that of operation`)}}checkRequiredProperty(t,r){if(!(r in t)){throw new RequiredPropertyError(r)}}checkHashAlgorithm(t,r){for(const o of r){if(o.toLowerCase()===t.name.toLowerCase()){return}}throw new OperationError(`hash: Must be one of ${r.join(", ")}`)}checkImportParams(t){}checkKeyFormat(t){switch(t){case"raw":case"pkcs8":case"spki":case"jwk":break;default:throw new TypeError("format: Is invalid value. Must be 'jwk', 'raw', 'spki', or 'pkcs8'")}}checkKeyData(t,r){if(!r){throw new TypeError("keyData: Cannot be empty on empty on key importing")}if(t==="jwk"){if(!isJWK(r)){throw new TypeError("keyData: Is not JsonWebToken")}}else if(!i.BufferSourceConverter.isBufferSource(r)){throw new TypeError("keyData: Is not ArrayBufferView or ArrayBuffer")}}prepareData(t){return i.BufferSourceConverter.toArrayBuffer(t)}}class AesProvider extends ProviderCrypto{checkGenerateKeyParams(t){this.checkRequiredProperty(t,"length");if(typeof t.length!=="number"){throw new TypeError("length: Is not of type Number")}switch(t.length){case 128:case 192:case 256:break;default:throw new TypeError("length: Must be 128, 192, or 256")}}checkDerivedKeyParams(t){this.checkGenerateKeyParams(t)}}class AesCbcProvider extends AesProvider{constructor(){super(...arguments);this.name="AES-CBC";this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(t){this.checkRequiredProperty(t,"iv");if(!(t.iv instanceof ArrayBuffer||ArrayBuffer.isView(t.iv))){throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'")}if(t.iv.byteLength!==16){throw new TypeError("iv: Must have length 16 bytes")}}}class AesCmacProvider extends AesProvider{constructor(){super(...arguments);this.name="AES-CMAC";this.usages=["sign","verify"]}checkAlgorithmParams(t){this.checkRequiredProperty(t,"length");if(typeof t.length!=="number"){throw new TypeError("length: Is not a Number")}if(t.length<1){throw new OperationError("length: Must be more than 0")}}}class AesCtrProvider extends AesProvider{constructor(){super(...arguments);this.name="AES-CTR";this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(t){this.checkRequiredProperty(t,"counter");if(!(t.counter instanceof ArrayBuffer||ArrayBuffer.isView(t.counter))){throw new TypeError("counter: Is not of type '(ArrayBuffer or ArrayBufferView)'")}if(t.counter.byteLength!==16){throw new TypeError("iv: Must have length 16 bytes")}this.checkRequiredProperty(t,"length");if(typeof t.length!=="number"){throw new TypeError("length: Is not a Number")}if(t.length<1){throw new OperationError("length: Must be more than 0")}}}class AesEcbProvider extends AesProvider{constructor(){super(...arguments);this.name="AES-ECB";this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}}class AesGcmProvider extends AesProvider{constructor(){super(...arguments);this.name="AES-GCM";this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(t){this.checkRequiredProperty(t,"iv");if(!(t.iv instanceof ArrayBuffer||ArrayBuffer.isView(t.iv))){throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'")}if(t.iv.byteLength<1){throw new OperationError("iv: Must have length more than 0 and less than 2^64 - 1")}if(!("tagLength"in t)){t.tagLength=128}switch(t.tagLength){case 32:case 64:case 96:case 104:case 112:case 120:case 128:break;default:throw new OperationError("tagLength: Must be one of 32, 64, 96, 104, 112, 120 or 128")}}}class AesKwProvider extends AesProvider{constructor(){super(...arguments);this.name="AES-KW";this.usages=["wrapKey","unwrapKey"]}}class DesProvider extends ProviderCrypto{constructor(){super(...arguments);this.usages=["encrypt","decrypt","wrapKey","unwrapKey"]}checkAlgorithmParams(t){if(this.ivSize){this.checkRequiredProperty(t,"iv");if(!(t.iv instanceof ArrayBuffer||ArrayBuffer.isView(t.iv))){throw new TypeError("iv: Is not of type '(ArrayBuffer or ArrayBufferView)'")}if(t.iv.byteLength!==this.ivSize){throw new TypeError(`iv: Must have length ${this.ivSize} bytes`)}}}checkGenerateKeyParams(t){this.checkRequiredProperty(t,"length");if(typeof t.length!=="number"){throw new TypeError("length: Is not of type Number")}if(t.length!==this.keySizeBits){throw new OperationError(`algorith.length: Must be ${this.keySizeBits}`)}}checkDerivedKeyParams(t){this.checkGenerateKeyParams(t)}}class RsaProvider extends ProviderCrypto{constructor(){super(...arguments);this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"]}checkGenerateKeyParams(t){this.checkRequiredProperty(t,"hash");this.checkHashAlgorithm(t.hash,this.hashAlgorithms);this.checkRequiredProperty(t,"publicExponent");if(!(t.publicExponent&&t.publicExponent instanceof Uint8Array)){throw new TypeError("publicExponent: Missing or not a Uint8Array")}const r=i.Convert.ToBase64(t.publicExponent);if(!(r==="Aw=="||r==="AQAB")){throw new TypeError("publicExponent: Must be [3] or [1,0,1]")}this.checkRequiredProperty(t,"modulusLength");switch(t.modulusLength){case 1024:case 2048:case 4096:break;default:throw new TypeError("modulusLength: Must be 1024, 2048, or 4096")}}checkImportParams(t){this.checkRequiredProperty(t,"hash");this.checkHashAlgorithm(t.hash,this.hashAlgorithms)}}class RsaSsaProvider extends RsaProvider{constructor(){super(...arguments);this.name="RSASSA-PKCS1-v1_5";this.usages={privateKey:["sign"],publicKey:["verify"]}}}class RsaPssProvider extends RsaProvider{constructor(){super(...arguments);this.name="RSA-PSS";this.usages={privateKey:["sign"],publicKey:["verify"]}}checkAlgorithmParams(t){this.checkRequiredProperty(t,"saltLength");if(typeof t.saltLength!=="number"){throw new TypeError("saltLength: Is not a Number")}if(t.saltLength<0){throw new RangeError("saltLength: Must be positive number")}}}class RsaOaepProvider extends RsaProvider{constructor(){super(...arguments);this.name="RSA-OAEP";this.usages={privateKey:["decrypt","unwrapKey"],publicKey:["encrypt","wrapKey"]}}checkAlgorithmParams(t){if(t.label&&!(t.label instanceof ArrayBuffer||ArrayBuffer.isView(t.label))){throw new TypeError("label: Is not of type '(ArrayBuffer or ArrayBufferView)'")}}}class EllipticProvider extends ProviderCrypto{checkGenerateKeyParams(t){this.checkRequiredProperty(t,"namedCurve");this.checkNamedCurve(t.namedCurve)}checkNamedCurve(t){for(const r of this.namedCurves){if(r.toLowerCase()===t.toLowerCase()){return}}throw new OperationError(`namedCurve: Must be one of ${this.namedCurves.join(", ")}`)}}class EcdsaProvider extends EllipticProvider{constructor(){super(...arguments);this.name="ECDSA";this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"];this.usages={privateKey:["sign"],publicKey:["verify"]};this.namedCurves=["P-256","P-384","P-521","K-256"]}checkAlgorithmParams(t){this.checkRequiredProperty(t,"hash");this.checkHashAlgorithm(t.hash,this.hashAlgorithms)}}const y=["secret","private","public"];class CryptoKey{static create(t,r,o,i){const a=new this;a.algorithm=t;a.type=r;a.extractable=o;a.usages=i;return a}static isKeyType(t){return y.indexOf(t)!==-1}get[Symbol.toStringTag](){return"CryptoKey"}}class EcdhProvider extends EllipticProvider{constructor(){super(...arguments);this.name="ECDH";this.usages={privateKey:["deriveBits","deriveKey"],publicKey:[]};this.namedCurves=["P-256","P-384","P-521","K-256"]}checkAlgorithmParams(t){this.checkRequiredProperty(t,"public");if(!(t.public instanceof CryptoKey)){throw new TypeError("public: Is not a CryptoKey")}if(t.public.type!=="public"){throw new OperationError("public: Is not a public key")}if(t.public.algorithm.name!==this.name){throw new OperationError(`public: Is not ${this.name} key`)}}}class EcdhEsProvider extends EcdhProvider{constructor(){super(...arguments);this.name="ECDH-ES";this.namedCurves=["X25519","X448"]}}class EdDsaProvider extends EllipticProvider{constructor(){super(...arguments);this.name="EdDSA";this.usages={privateKey:["sign"],publicKey:["verify"]};this.namedCurves=["Ed25519","Ed448"]}}class HmacProvider extends ProviderCrypto{constructor(){super(...arguments);this.name="HMAC";this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"];this.usages=["sign","verify"]}getDefaultLength(t){switch(t.toUpperCase()){case"SHA-1":case"SHA-256":case"SHA-384":case"SHA-512":return 512;default:throw new Error(`Unknown algorithm name '${t}'`)}}checkGenerateKeyParams(t){this.checkRequiredProperty(t,"hash");this.checkHashAlgorithm(t.hash,this.hashAlgorithms);if("length"in t){if(typeof t.length!=="number"){throw new TypeError("length: Is not a Number")}if(t.length<1){throw new RangeError("length: Number is out of range")}}}checkImportParams(t){this.checkRequiredProperty(t,"hash");this.checkHashAlgorithm(t.hash,this.hashAlgorithms)}}class Pbkdf2Provider extends ProviderCrypto{constructor(){super(...arguments);this.name="PBKDF2";this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"];this.usages=["deriveBits","deriveKey"]}checkAlgorithmParams(t){this.checkRequiredProperty(t,"hash");this.checkHashAlgorithm(t.hash,this.hashAlgorithms);this.checkRequiredProperty(t,"salt");if(!(t.salt instanceof ArrayBuffer||ArrayBuffer.isView(t.salt))){throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'")}this.checkRequiredProperty(t,"iterations");if(typeof t.iterations!=="number"){throw new TypeError("iterations: Is not a Number")}if(t.iterations<1){throw new TypeError("iterations: Is less than 1")}}checkImportKey(t,r,o,i,a,...c){super.checkImportKey(t,r,o,i,a);if(i){throw new SyntaxError("extractable: Must be 'false'")}}}class HkdfProvider extends ProviderCrypto{constructor(){super(...arguments);this.name="HKDF";this.hashAlgorithms=["SHA-1","SHA-256","SHA-384","SHA-512"];this.usages=["deriveKey","deriveBits"]}checkAlgorithmParams(t){this.checkRequiredProperty(t,"hash");this.checkHashAlgorithm(t.hash,this.hashAlgorithms);this.checkRequiredProperty(t,"salt");if(!i.BufferSourceConverter.isBufferSource(t.salt)){throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'")}this.checkRequiredProperty(t,"info");if(!i.BufferSourceConverter.isBufferSource(t.info)){throw new TypeError("salt: Is not of type '(ArrayBuffer or ArrayBufferView)'")}}checkImportKey(t,r,o,i,a,...c){super.checkImportKey(t,r,o,i,a);if(i){throw new SyntaxError("extractable: Must be 'false'")}}}class Crypto{get[Symbol.toStringTag](){return"Crypto"}}class ProviderStorage{constructor(){this.items={}}get(t){return this.items[t.toLowerCase()]||null}set(t){this.items[t.name.toLowerCase()]=t}removeAt(t){const r=this.get(t.toLowerCase());if(r){delete this.items[t]}return r}has(t){return!!this.get(t)}get length(){return Object.keys(this.items).length}get algorithms(){const t=[];for(const r in this.items){const o=this.items[r];t.push(o.name)}return t.sort()}}class SubtleCrypto{constructor(){this.providers=new ProviderStorage}static isHashedAlgorithm(t){return t&&typeof t==="object"&&"name"in t&&"hash"in t?true:false}get[Symbol.toStringTag](){return"SubtleCrypto"}async digest(...t){this.checkRequiredArguments(t,2,"digest");const[r,o,...a]=t;const c=this.prepareAlgorithm(r);const l=i.BufferSourceConverter.toArrayBuffer(o);const u=this.getProvider(c.name);const h=await u.digest(c,l,...a);return h}async generateKey(...t){this.checkRequiredArguments(t,3,"generateKey");const[r,o,i,...a]=t;const c=this.prepareAlgorithm(r);const l=this.getProvider(c.name);const u=await l.generateKey({...c,name:l.name},o,i,...a);return u}async sign(...t){this.checkRequiredArguments(t,3,"sign");const[r,o,a,...c]=t;this.checkCryptoKey(o);const l=this.prepareAlgorithm(r);const u=i.BufferSourceConverter.toArrayBuffer(a);const h=this.getProvider(l.name);const y=await h.sign({...l,name:h.name},o,u,...c);return y}async verify(...t){this.checkRequiredArguments(t,4,"verify");const[r,o,a,c,...l]=t;this.checkCryptoKey(o);const u=this.prepareAlgorithm(r);const h=i.BufferSourceConverter.toArrayBuffer(c);const y=i.BufferSourceConverter.toArrayBuffer(a);const p=this.getProvider(u.name);const d=await p.verify({...u,name:p.name},o,y,h,...l);return d}async encrypt(...t){this.checkRequiredArguments(t,3,"encrypt");const[r,o,a,...c]=t;this.checkCryptoKey(o);const l=this.prepareAlgorithm(r);const u=i.BufferSourceConverter.toArrayBuffer(a);const h=this.getProvider(l.name);const y=await h.encrypt({...l,name:h.name},o,u,{keyUsage:true},...c);return y}async decrypt(...t){this.checkRequiredArguments(t,3,"decrypt");const[r,o,a,...c]=t;this.checkCryptoKey(o);const l=this.prepareAlgorithm(r);const u=i.BufferSourceConverter.toArrayBuffer(a);const h=this.getProvider(l.name);const y=await h.decrypt({...l,name:h.name},o,u,{keyUsage:true},...c);return y}async deriveBits(...t){this.checkRequiredArguments(t,3,"deriveBits");const[r,o,i,...a]=t;this.checkCryptoKey(o);const c=this.prepareAlgorithm(r);const l=this.getProvider(c.name);const u=await l.deriveBits({...c,name:l.name},o,i,{keyUsage:true},...a);return u}async deriveKey(...t){this.checkRequiredArguments(t,5,"deriveKey");const[r,o,i,a,c,...l]=t;const u=this.prepareAlgorithm(i);const h=this.getProvider(u.name);h.checkDerivedKeyParams(u);const y=this.prepareAlgorithm(r);const p=this.getProvider(y.name);p.checkCryptoKey(o,"deriveKey");const d=await p.deriveBits({...y,name:p.name},o,i.length||512,{keyUsage:false},...l);return this.importKey("raw",d,i,a,c,...l)}async exportKey(...t){this.checkRequiredArguments(t,2,"exportKey");const[r,o,...i]=t;this.checkCryptoKey(o);const a=this.getProvider(o.algorithm.name);const c=await a.exportKey(r,o,...i);return c}async importKey(...t){this.checkRequiredArguments(t,5,"importKey");const[r,o,a,c,l,...u]=t;const h=this.prepareAlgorithm(a);const y=this.getProvider(h.name);if(["pkcs8","spki","raw"].indexOf(r)!==-1){const t=i.BufferSourceConverter.toArrayBuffer(o);return y.importKey(r,t,{...h,name:y.name},c,l,...u)}else{if(!o.kty){throw new TypeError("keyData: Is not JSON")}}return y.importKey(r,o,{...h,name:y.name},c,l,...u)}async wrapKey(t,r,o,a,...c){let l=await this.exportKey(t,r,...c);if(t==="jwk"){const t=JSON.stringify(l);l=i.Convert.FromUtf8String(t)}const u=this.prepareAlgorithm(a);const h=i.BufferSourceConverter.toArrayBuffer(l);const y=this.getProvider(u.name);return y.encrypt({...u,name:y.name},o,h,{keyUsage:false},...c)}async unwrapKey(t,r,o,a,c,l,u,...h){const y=this.prepareAlgorithm(a);const p=i.BufferSourceConverter.toArrayBuffer(r);const d=this.getProvider(y.name);let g=await d.decrypt({...y,name:d.name},o,p,{keyUsage:false},...h);if(t==="jwk"){try{g=JSON.parse(i.Convert.ToUtf8String(g))}catch(t){const r=new TypeError("wrappedKey: Is not a JSON");r.internal=t;throw r}}return this.importKey(t,g,c,l,u,...h)}checkRequiredArguments(t,r,o){if(t.length<r){throw new TypeError(`Failed to execute '${o}' on 'SubtleCrypto': ${r} arguments required, but only ${t.length} present`)}}prepareAlgorithm(t){if(typeof t==="string"){return{name:t}}if(SubtleCrypto.isHashedAlgorithm(t)){const r={...t};r.hash=this.prepareAlgorithm(t.hash);return r}return{...t}}getProvider(t){const r=this.providers.get(t);if(!r){throw new AlgorithmError("Unrecognized name")}return r}checkCryptoKey(t){if(!(t instanceof CryptoKey)){throw new TypeError(`Key is not of type 'CryptoKey'`)}}}let p=class ObjectIdentifier{constructor(t){if(t){this.value=t}}};a.__decorate([c.AsnProp({type:c.AsnPropTypes.ObjectIdentifier})],p.prototype,"value",void 0);p=a.__decorate([c.AsnType({type:c.AsnTypeTypes.Choice})],p);class AlgorithmIdentifier{constructor(t){Object.assign(this,t)}}a.__decorate([c.AsnProp({type:c.AsnPropTypes.ObjectIdentifier})],AlgorithmIdentifier.prototype,"algorithm",void 0);a.__decorate([c.AsnProp({type:c.AsnPropTypes.Any,optional:true})],AlgorithmIdentifier.prototype,"parameters",void 0);class PrivateKeyInfo{constructor(){this.version=0;this.privateKeyAlgorithm=new AlgorithmIdentifier;this.privateKey=new ArrayBuffer(0)}}a.__decorate([c.AsnProp({type:c.AsnPropTypes.Integer})],PrivateKeyInfo.prototype,"version",void 0);a.__decorate([c.AsnProp({type:AlgorithmIdentifier})],PrivateKeyInfo.prototype,"privateKeyAlgorithm",void 0);a.__decorate([c.AsnProp({type:c.AsnPropTypes.OctetString})],PrivateKeyInfo.prototype,"privateKey",void 0);a.__decorate([c.AsnProp({type:c.AsnPropTypes.Any,optional:true})],PrivateKeyInfo.prototype,"attributes",void 0);class PublicKeyInfo{constructor(){this.publicKeyAlgorithm=new AlgorithmIdentifier;this.publicKey=new ArrayBuffer(0)}}a.__decorate([c.AsnProp({type:AlgorithmIdentifier})],PublicKeyInfo.prototype,"publicKeyAlgorithm",void 0);a.__decorate([c.AsnProp({type:c.AsnPropTypes.BitString})],PublicKeyInfo.prototype,"publicKey",void 0);const d={fromJSON:t=>i.Convert.FromBase64Url(t),toJSON:t=>i.Convert.ToBase64Url(new Uint8Array(t))};const g={fromASN:t=>{const r=t.valueBlock.valueHex;return!new Uint8Array(r)[0]?t.valueBlock.valueHex.slice(1):t.valueBlock.valueHex},toASN:t=>{const r=new Uint8Array(t)[0]>127?Buffer.concat([Buffer.from([0]),Buffer.from(t)]):Buffer.from(t);return new h.Integer({valueHex:new Uint8Array(r).buffer})}};var m=Object.freeze({__proto__:null,JsonBase64UrlArrayBufferConverter:d,AsnIntegerArrayBufferConverter:g});class RsaPrivateKey{constructor(){this.version=0;this.modulus=new ArrayBuffer(0);this.publicExponent=new ArrayBuffer(0);this.privateExponent=new ArrayBuffer(0);this.prime1=new ArrayBuffer(0);this.prime2=new ArrayBuffer(0);this.exponent1=new ArrayBuffer(0);this.exponent2=new ArrayBuffer(0);this.coefficient=new ArrayBuffer(0)}}a.__decorate([c.AsnProp({type:c.AsnPropTypes.Integer,converter:c.AsnIntegerConverter})],RsaPrivateKey.prototype,"version",void 0);a.__decorate([c.AsnProp({type:c.AsnPropTypes.Integer,converter:g}),l.JsonProp({name:"n",converter:d})],RsaPrivateKey.prototype,"modulus",void 0);a.__decorate([c.AsnProp({type:c.AsnPropTypes.Integer,converter:g}),l.JsonProp({name:"e",converter:d})],RsaPrivateKey.prototype,"publicExponent",void 0);a.__decorate([c.AsnProp({type:c.AsnPropTypes.Integer,converter:g}),l.JsonProp({name:"d",converter:d})],RsaPrivateKey.prototype,"privateExponent",void 0);a.__decorate([c.AsnProp({type:c.AsnPropTypes.Integer,converter:g}),l.JsonProp({name:"p",converter:d})],RsaPrivateKey.prototype,"prime1",void 0);a.__decorate([c.AsnProp({type:c.AsnPropTypes.Integer,converter:g}),l.JsonProp({name:"q",converter:d})],RsaPrivateKey.prototype,"prime2",void 0);a.__decorate([c.AsnProp({type:c.AsnPropTypes.Integer,converter:g}),l.JsonProp({name:"dp",converter:d})],RsaPrivateKey.prototype,"exponent1",void 0);a.__decorate([c.AsnProp({type:c.AsnPropTypes.Integer,converter:g}),l.JsonProp({name:"dq",converter:d})],RsaPrivateKey.prototype,"exponent2",void 0);a.__decorate([c.AsnProp({type:c.AsnPropTypes.Integer,converter:g}),l.JsonProp({name:"qi",converter:d})],RsaPrivateKey.prototype,"coefficient",void 0);a.__decorate([c.AsnProp({type:c.AsnPropTypes.Any,optional:true})],RsaPrivateKey.prototype,"otherPrimeInfos",void 0);class RsaPublicKey{constructor(){this.modulus=new ArrayBuffer(0);this.publicExponent=new ArrayBuffer(0)}}a.__decorate([c.AsnProp({type:c.AsnPropTypes.Integer,converter:g}),l.JsonProp({name:"n",converter:d})],RsaPublicKey.prototype,"modulus",void 0);a.__decorate([c.AsnProp({type:c.AsnPropTypes.Integer,converter:g}),l.JsonProp({name:"e",converter:d})],RsaPublicKey.prototype,"publicExponent",void 0);let v=class EcPublicKey{constructor(t){this.value=new ArrayBuffer(0);if(t){this.value=t}}toJSON(){let t=new Uint8Array(this.value);if(t[0]!==4){throw new CryptoError("Wrong ECPoint. Current version supports only Uncompressed (0x04) point")}t=new Uint8Array(this.value.slice(1));const r=t.length/2;const o=0;const a={x:i.Convert.ToBase64Url(t.buffer.slice(o,o+r)),y:i.Convert.ToBase64Url(t.buffer.slice(o+r,o+r+r))};return a}fromJSON(t){if(!("x"in t)){throw new Error("x: Missing required property")}if(!("y"in t)){throw new Error("y: Missing required property")}const r=i.Convert.FromBase64Url(t.x);const o=i.Convert.FromBase64Url(t.y);const a=Buffer.concat([new Uint8Array([4]),new Uint8Array(r),new Uint8Array(o)]);this.value=new Uint8Array(a).buffer;return this}};a.__decorate([c.AsnProp({type:c.AsnPropTypes.OctetString})],v.prototype,"value",void 0);v=a.__decorate([c.AsnType({type:c.AsnTypeTypes.Choice})],v);class EcPrivateKey{constructor(){this.version=1;this.privateKey=new ArrayBuffer(0)}fromJSON(t){if(!("d"in t)){throw new Error("d: Missing required property")}this.privateKey=i.Convert.FromBase64Url(t.d);if("x"in t){const r=new v;r.fromJSON(t);this.publicKey=c.AsnSerializer.toASN(r).valueBlock.valueHex}return this}toJSON(){const t={};t.d=i.Convert.ToBase64Url(this.privateKey);if(this.publicKey){Object.assign(t,new v(this.publicKey).toJSON())}return t}}a.__decorate([c.AsnProp({type:c.AsnPropTypes.Integer,converter:c.AsnIntegerConverter})],EcPrivateKey.prototype,"version",void 0);a.__decorate([c.AsnProp({type:c.AsnPropTypes.OctetString})],EcPrivateKey.prototype,"privateKey",void 0);a.__decorate([c.AsnProp({context:0,type:c.AsnPropTypes.Any,optional:true})],EcPrivateKey.prototype,"parameters",void 0);a.__decorate([c.AsnProp({context:1,type:c.AsnPropTypes.BitString,optional:true})],EcPrivateKey.prototype,"publicKey",void 0);const b={fromASN:t=>{const r=new Uint8Array(t.valueBlock.valueHex);return r[0]===0?r.buffer.slice(1):r.buffer},toASN:t=>{const r=new Uint8Array(t);if(r[0]>127){const t=new Uint8Array(r.length+1);t.set(r,1);return new h.Integer({valueHex:t.buffer})}return new h.Integer({valueHex:t})}};var w=Object.freeze({__proto__:null,AsnIntegerWithoutPaddingConverter:b});class EcDsaSignature{constructor(){this.r=new ArrayBuffer(0);this.s=new ArrayBuffer(0)}static fromWebCryptoSignature(t){const r=i.BufferSourceConverter.toUint8Array(t);const o=r.byteLength/2;const a=new this;a.r=a.removePadding(r.slice(0,o));a.s=a.removePadding(r.slice(o,o*2));return a}toWebCryptoSignature(t){t=this.getPointSize();const r=this.addPadding(t,i.BufferSourceConverter.toUint8Array(this.r));const o=this.addPadding(t,i.BufferSourceConverter.toUint8Array(this.s));const a=new Uint8Array(r.byteLength+o.byteLength);a.set(r,0);a.set(o,r.length);return a.buffer}getPointSize(){const t=Math.max(this.r.byteLength,this.s.byteLength);switch(t){case 31:case 32:return 32;case 47:case 48:return 48;case 65:case 66:return 66}throw new Error("Unsupported EC point size")}addPadding(t,r){const o=new Uint8Array(t);const a=i.BufferSourceConverter.toUint8Array(r);o.set(a,t-a.length);return o}removePadding(t){const r=i.BufferSourceConverter.toUint8Array(t);for(let t=0;t<r.length;t++){if(!r[t]){continue}return r.slice(t)}return new Uint8Array(0)}}a.__decorate([c.AsnProp({type:c.AsnPropTypes.Integer,converter:b})],EcDsaSignature.prototype,"r",void 0);a.__decorate([c.AsnProp({type:c.AsnPropTypes.Integer,converter:b})],EcDsaSignature.prototype,"s",void 0);let A=class CurvePrivateKey{};a.__decorate([c.AsnProp({type:c.AsnPropTypes.OctetString}),l.JsonProp({type:l.JsonPropTypes.String,converter:d})],A.prototype,"d",void 0);A=a.__decorate([c.AsnType({type:c.AsnTypeTypes.Choice})],A);const B="1.3.101.110";const S="1.3.101.111";const k="1.3.101.112";const C="1.3.101.113";var P=Object.freeze({__proto__:null,converters:w,get ObjectIdentifier(){return p},AlgorithmIdentifier:AlgorithmIdentifier,PrivateKeyInfo:PrivateKeyInfo,PublicKeyInfo:PublicKeyInfo,RsaPrivateKey:RsaPrivateKey,RsaPublicKey:RsaPublicKey,EcPrivateKey:EcPrivateKey,get EcPublicKey(){return v},EcDsaSignature:EcDsaSignature,get CurvePrivateKey(){return A},idX25519:B,idX448:S,idEd25519:k,idEd448:C});var E=Object.freeze({__proto__:null,converters:m});Object.defineProperty(r,"BufferSourceConverter",{enumerable:true,get:function(){return i.BufferSourceConverter}});r.AesCbcProvider=AesCbcProvider;r.AesCmacProvider=AesCmacProvider;r.AesCtrProvider=AesCtrProvider;r.AesEcbProvider=AesEcbProvider;r.AesGcmProvider=AesGcmProvider;r.AesKwProvider=AesKwProvider;r.AesProvider=AesProvider;r.AlgorithmError=AlgorithmError;r.Crypto=Crypto;r.CryptoError=CryptoError;r.CryptoKey=CryptoKey;r.DesProvider=DesProvider;r.EcdhEsProvider=EcdhEsProvider;r.EcdhProvider=EcdhProvider;r.EcdsaProvider=EcdsaProvider;r.EdDsaProvider=EdDsaProvider;r.EllipticProvider=EllipticProvider;r.HkdfProvider=HkdfProvider;r.HmacProvider=HmacProvider;r.OperationError=OperationError;r.Pbkdf2Provider=Pbkdf2Provider;r.PemConverter=PemConverter;r.ProviderCrypto=ProviderCrypto;r.ProviderStorage=ProviderStorage;r.RequiredPropertyError=RequiredPropertyError;r.RsaOaepProvider=RsaOaepProvider;r.RsaProvider=RsaProvider;r.RsaPssProvider=RsaPssProvider;r.RsaSsaProvider=RsaSsaProvider;r.SubtleCrypto=SubtleCrypto;r.UnsupportedOperationError=UnsupportedOperationError;r.asn1=P;r.isJWK=isJWK;r.json=E},761:t=>{
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var r;var o;var i;var a;var c;var l;var u;var h;var y;var p;var d;var g;var m;var v;var b;var w;var A;var B;var S;var k;var C;var P;var E;var K;(function(r){var o=typeof global==="object"?global:typeof self==="object"?self:typeof this==="object"?this:{};if(typeof define==="function"&&define.amd){define("tslib",["exports"],(function(t){r(createExporter(o,createExporter(t)))}))}else if(true&&typeof t.exports==="object"){r(createExporter(o,createExporter(t.exports)))}else{r(createExporter(o))}function createExporter(t,r){if(t!==o){if(typeof Object.create==="function"){Object.defineProperty(t,"__esModule",{value:true})}else{t.__esModule=true}}return function(o,i){return t[o]=r?r(o,i):i}}})((function(t){var x=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,r){t.__proto__=r}||function(t,r){for(var o in r)if(Object.prototype.hasOwnProperty.call(r,o))t[o]=r[o]};r=function(t,r){if(typeof r!=="function"&&r!==null)throw new TypeError("Class extends value "+String(r)+" is not a constructor or null");x(t,r);function __(){this.constructor=t}t.prototype=r===null?Object.create(r):(__.prototype=r.prototype,new __)};o=Object.assign||function(t){for(var r,o=1,i=arguments.length;o<i;o++){r=arguments[o];for(var a in r)if(Object.prototype.hasOwnProperty.call(r,a))t[a]=r[a]}return t};i=function(t,r){var o={};for(var i in t)if(Object.prototype.hasOwnProperty.call(t,i)&&r.indexOf(i)<0)o[i]=t[i];if(t!=null&&typeof Object.getOwnPropertySymbols==="function")for(var a=0,i=Object.getOwnPropertySymbols(t);a<i.length;a++){if(r.indexOf(i[a])<0&&Object.prototype.propertyIsEnumerable.call(t,i[a]))o[i[a]]=t[i[a]]}return o};a=function(t,r,o,i){var a=arguments.length,c=a<3?r:i===null?i=Object.getOwnPropertyDescriptor(r,o):i,l;if(typeof Reflect==="object"&&typeof Reflect.decorate==="function")c=Reflect.decorate(t,r,o,i);else for(var u=t.length-1;u>=0;u--)if(l=t[u])c=(a<3?l(c):a>3?l(r,o,c):l(r,o))||c;return a>3&&c&&Object.defineProperty(r,o,c),c};c=function(t,r){return function(o,i){r(o,i,t)}};l=function(t,r){if(typeof Reflect==="object"&&typeof Reflect.metadata==="function")return Reflect.metadata(t,r)};u=function(t,r,o,i){function adopt(t){return t instanceof o?t:new o((function(r){r(t)}))}return new(o||(o=Promise))((function(o,a){function fulfilled(t){try{step(i.next(t))}catch(t){a(t)}}function rejected(t){try{step(i["throw"](t))}catch(t){a(t)}}function step(t){t.done?o(t.value):adopt(t.value).then(fulfilled,rejected)}step((i=i.apply(t,r||[])).next())}))};h=function(t,r){var o={label:0,sent:function(){if(c[0]&1)throw c[1];return c[1]},trys:[],ops:[]},i,a,c,l;return l={next:verb(0),throw:verb(1),return:verb(2)},typeof Symbol==="function"&&(l[Symbol.iterator]=function(){return this}),l;function verb(t){return function(r){return step([t,r])}}function step(l){if(i)throw new TypeError("Generator is already executing.");while(o)try{if(i=1,a&&(c=l[0]&2?a["return"]:l[0]?a["throw"]||((c=a["return"])&&c.call(a),0):a.next)&&!(c=c.call(a,l[1])).done)return c;if(a=0,c)l=[l[0]&2,c.value];switch(l[0]){case 0:case 1:c=l;break;case 4:o.label++;return{value:l[1],done:false};case 5:o.label++;a=l[1];l=[0];continue;case 7:l=o.ops.pop();o.trys.pop();continue;default:if(!(c=o.trys,c=c.length>0&&c[c.length-1])&&(l[0]===6||l[0]===2)){o=0;continue}if(l[0]===3&&(!c||l[1]>c[0]&&l[1]<c[3])){o.label=l[1];break}if(l[0]===6&&o.label<c[1]){o.label=c[1];c=l;break}if(c&&o.label<c[2]){o.label=c[2];o.ops.push(l);break}if(c[2])o.ops.pop();o.trys.pop();continue}l=r.call(t,o)}catch(t){l=[6,t];a=0}finally{i=c=0}if(l[0]&5)throw l[1];return{value:l[0]?l[1]:void 0,done:true}}};y=function(t,r){for(var o in t)if(o!=="default"&&!Object.prototype.hasOwnProperty.call(r,o))K(r,t,o)};K=Object.create?function(t,r,o,i){if(i===undefined)i=o;Object.defineProperty(t,i,{enumerable:true,get:function(){return r[o]}})}:function(t,r,o,i){if(i===undefined)i=o;t[i]=r[o]};p=function(t){var r=typeof Symbol==="function"&&Symbol.iterator,o=r&&t[r],i=0;if(o)return o.call(t);if(t&&typeof t.length==="number")return{next:function(){if(t&&i>=t.length)t=void 0;return{value:t&&t[i++],done:!t}}};throw new TypeError(r?"Object is not iterable.":"Symbol.iterator is not defined.")};d=function(t,r){var o=typeof Symbol==="function"&&t[Symbol.iterator];if(!o)return t;var i=o.call(t),a,c=[],l;try{while((r===void 0||r-- >0)&&!(a=i.next()).done)c.push(a.value)}catch(t){l={error:t}}finally{try{if(a&&!a.done&&(o=i["return"]))o.call(i)}finally{if(l)throw l.error}}return c};g=function(){for(var t=[],r=0;r<arguments.length;r++)t=t.concat(d(arguments[r]));return t};m=function(){for(var t=0,r=0,o=arguments.length;r<o;r++)t+=arguments[r].length;for(var i=Array(t),a=0,r=0;r<o;r++)for(var c=arguments[r],l=0,u=c.length;l<u;l++,a++)i[a]=c[l];return i};v=function(t,r,o){if(o||arguments.length===2)for(var i=0,a=r.length,c;i<a;i++){if(c||!(i in r)){if(!c)c=Array.prototype.slice.call(r,0,i);c[i]=r[i]}}return t.concat(c||Array.prototype.slice.call(r))};b=function(t){return this instanceof b?(this.v=t,this):new b(t)};w=function(t,r,o){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var i=o.apply(t,r||[]),a,c=[];return a={},verb("next"),verb("throw"),verb("return"),a[Symbol.asyncIterator]=function(){return this},a;function verb(t){if(i[t])a[t]=function(r){return new Promise((function(o,i){c.push([t,r,o,i])>1||resume(t,r)}))}}function resume(t,r){try{step(i[t](r))}catch(t){settle(c[0][3],t)}}function step(t){t.value instanceof b?Promise.resolve(t.value.v).then(fulfill,reject):settle(c[0][2],t)}function fulfill(t){resume("next",t)}function reject(t){resume("throw",t)}function settle(t,r){if(t(r),c.shift(),c.length)resume(c[0][0],c[0][1])}};A=function(t){var r,o;return r={},verb("next"),verb("throw",(function(t){throw t})),verb("return"),r[Symbol.iterator]=function(){return this},r;function verb(i,a){r[i]=t[i]?function(r){return(o=!o)?{value:b(t[i](r)),done:i==="return"}:a?a(r):r}:a}};B=function(t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var r=t[Symbol.asyncIterator],o;return r?r.call(t):(t=typeof p==="function"?p(t):t[Symbol.iterator](),o={},verb("next"),verb("throw"),verb("return"),o[Symbol.asyncIterator]=function(){return this},o);function verb(r){o[r]=t[r]&&function(o){return new Promise((function(i,a){o=t[r](o),settle(i,a,o.done,o.value)}))}}function settle(t,r,o,i){Promise.resolve(i).then((function(r){t({value:r,done:o})}),r)}};S=function(t,r){if(Object.defineProperty){Object.defineProperty(t,"raw",{value:r})}else{t.raw=r}return t};var O=Object.create?function(t,r){Object.defineProperty(t,"default",{enumerable:true,value:r})}:function(t,r){t["default"]=r};k=function(t){if(t&&t.__esModule)return t;var r={};if(t!=null)for(var o in t)if(o!=="default"&&Object.prototype.hasOwnProperty.call(t,o))K(r,t,o);O(r,t);return r};C=function(t){return t&&t.__esModule?t:{default:t}};P=function(t,r,o,i){if(o==="a"&&!i)throw new TypeError("Private accessor was defined without a getter");if(typeof r==="function"?t!==r||!i:!r.has(t))throw new TypeError("Cannot read private member from an object whose class did not declare it");return o==="m"?i:o==="a"?i.call(t):i?i.value:r.get(t)};E=function(t,r,o,i,a){if(i==="m")throw new TypeError("Private method is not writable");if(i==="a"&&!a)throw new TypeError("Private accessor was defined without a setter");if(typeof r==="function"?t!==r||!a:!r.has(t))throw new TypeError("Cannot write private member to an object whose class did not declare it");return i==="a"?a.call(t,o):a?a.value=o:r.set(t,o),o};t("__extends",r);t("__assign",o);t("__rest",i);t("__decorate",a);t("__param",c);t("__metadata",l);t("__awaiter",u);t("__generator",h);t("__exportStar",y);t("__createBinding",K);t("__values",p);t("__read",d);t("__spread",g);t("__spreadArrays",m);t("__spreadArray",v);t("__await",b);t("__asyncGenerator",w);t("__asyncDelegator",A);t("__asyncValues",B);t("__makeTemplateObject",S);t("__importStar",k);t("__importDefault",C);t("__classPrivateFieldGet",P);t("__classPrivateFieldSet",E)}))},113:t=>{"use strict";t.exports=require("crypto")},282:t=>{"use strict";t.exports=require("process")}};var r={};function __nccwpck_require__(o){var i=r[o];if(i!==undefined){return i.exports}var a=r[o]={exports:{}};var c=true;try{t[o].call(a.exports,a,a.exports,__nccwpck_require__);c=false}finally{if(c)delete r[o]}return a.exports}if(typeof __nccwpck_require__!=="undefined")__nccwpck_require__.ab=__dirname+"/";var o={};(()=>{"use strict";var t=o;Object.defineProperty(t,"__esModule",{value:true});var r=__nccwpck_require__(837);var i=__nccwpck_require__(113);var a=__nccwpck_require__(282);var c=__nccwpck_require__(632);var l=__nccwpck_require__(628);var u=__nccwpck_require__(7);var h=__nccwpck_require__(297);function _interopDefaultLegacy(t){return t&&typeof t==="object"&&"default"in t?t:{default:t}}function _interopNamespace(t){if(t&&t.__esModule)return t;var r=Object.create(null);if(t){Object.keys(t).forEach((function(o){if(o!=="default"){var i=Object.getOwnPropertyDescriptor(t,o);Object.defineProperty(r,o,i.get?i:{enumerable:true,get:function(){return t[o]}})}}))}r["default"]=t;return Object.freeze(r)}var y=_interopNamespace(r);var p=_interopDefaultLegacy(i);var d=_interopNamespace(i);var g=_interopNamespace(a);const m={fromJSON:t=>Buffer.from(u.Convert.FromBase64Url(t)),toJSON:t=>u.Convert.ToBase64Url(t)};class CryptoKey extends y.CryptoKey{constructor(){super(...arguments);this.data=Buffer.alloc(0);this.algorithm={name:""};this.extractable=false;this.type="secret";this.usages=[];this.kty="oct";this.alg=""}}c.__decorate([l.JsonProp({name:"ext",type:l.JsonPropTypes.Boolean,optional:true})],CryptoKey.prototype,"extractable",void 0);c.__decorate([l.JsonProp({name:"key_ops",type:l.JsonPropTypes.String,repeated:true,optional:true})],CryptoKey.prototype,"usages",void 0);c.__decorate([l.JsonProp({type:l.JsonPropTypes.String})],CryptoKey.prototype,"kty",void 0);c.__decorate([l.JsonProp({type:l.JsonPropTypes.String})],CryptoKey.prototype,"alg",void 0);class SymmetricKey extends CryptoKey{constructor(){super(...arguments);this.kty="oct";this.type="secret"}}class AsymmetricKey extends CryptoKey{}class AesCryptoKey extends SymmetricKey{get alg(){switch(this.algorithm.name.toUpperCase()){case"AES-CBC":return`A${this.algorithm.length}CBC`;case"AES-CTR":return`A${this.algorithm.length}CTR`;case"AES-GCM":return`A${this.algorithm.length}GCM`;case"AES-KW":return`A${this.algorithm.length}KW`;case"AES-CMAC":return`A${this.algorithm.length}CMAC`;case"AES-ECB":return`A${this.algorithm.length}ECB`;default:throw new y.AlgorithmError("Unsupported algorithm name")}}set alg(t){}}c.__decorate([l.JsonProp({name:"k",converter:m})],AesCryptoKey.prototype,"data",void 0);const v=new WeakMap;function getCryptoKey(t){const r=v.get(t);if(!r){throw new y.OperationError("Cannot get CryptoKey from secure storage")}return r}function setCryptoKey(t){const r=y.CryptoKey.create(t.algorithm,t.type,t.extractable,t.usages);Object.freeze(r);v.set(r,t);return r}class AesCrypto{static async generateKey(t,r,o){const i=new AesCryptoKey;i.algorithm=t;i.extractable=r;i.usages=o;i.data=p["default"].randomBytes(t.length>>3);return i}static async exportKey(t,r){if(!(r instanceof AesCryptoKey)){throw new Error("key: Is not AesCryptoKey")}switch(t.toLowerCase()){case"jwk":return l.JsonSerializer.toJSON(r);case"raw":return new Uint8Array(r.data).buffer;default:throw new y.OperationError("format: Must be 'jwk' or 'raw'")}}static async importKey(t,r,o,i,a){let c;switch(t.toLowerCase()){case"jwk":c=l.JsonParser.fromJSON(r,{targetSchema:AesCryptoKey});break;case"raw":c=new AesCryptoKey;c.data=Buffer.from(r);break;default:throw new y.OperationError("format: Must be 'jwk' or 'raw'")}c.algorithm=o;c.algorithm.length=c.data.length<<3;c.extractable=i;c.usages=a;switch(c.algorithm.length){case 128:case 192:case 256:break;default:throw new y.OperationError("keyData: Is wrong key length")}return c}static async encrypt(t,r,o){switch(t.name.toUpperCase()){case"AES-CBC":return this.encryptAesCBC(t,r,Buffer.from(o));case"AES-CTR":return this.encryptAesCTR(t,r,Buffer.from(o));case"AES-GCM":return this.encryptAesGCM(t,r,Buffer.from(o));case"AES-KW":return this.encryptAesKW(t,r,Buffer.from(o));case"AES-ECB":return this.encryptAesECB(t,r,Buffer.from(o));default:throw new y.OperationError("algorithm: Is not recognized")}}static async decrypt(t,r,o){if(!(r instanceof AesCryptoKey)){throw new Error("key: Is not AesCryptoKey")}switch(t.name.toUpperCase()){case"AES-CBC":return this.decryptAesCBC(t,r,Buffer.from(o));case"AES-CTR":return this.decryptAesCTR(t,r,Buffer.from(o));case"AES-GCM":return this.decryptAesGCM(t,r,Buffer.from(o));case"AES-KW":return this.decryptAesKW(t,r,Buffer.from(o));case"AES-ECB":return this.decryptAesECB(t,r,Buffer.from(o));default:throw new y.OperationError("algorithm: Is not recognized")}}static async encryptAesCBC(t,r,o){const i=p["default"].createCipheriv(`aes-${r.algorithm.length}-cbc`,r.data,new Uint8Array(t.iv));let a=i.update(o);a=Buffer.concat([a,i.final()]);const c=new Uint8Array(a).buffer;return c}static async decryptAesCBC(t,r,o){const i=p["default"].createDecipheriv(`aes-${r.algorithm.length}-cbc`,r.data,new Uint8Array(t.iv));let a=i.update(o);a=Buffer.concat([a,i.final()]);return new Uint8Array(a).buffer}static async encryptAesCTR(t,r,o){const i=p["default"].createCipheriv(`aes-${r.algorithm.length}-ctr`,r.data,Buffer.from(t.counter));let a=i.update(o);a=Buffer.concat([a,i.final()]);const c=new Uint8Array(a).buffer;return c}static async decryptAesCTR(t,r,o){const i=p["default"].createDecipheriv(`aes-${r.algorithm.length}-ctr`,r.data,new Uint8Array(t.counter));let a=i.update(o);a=Buffer.concat([a,i.final()]);return new Uint8Array(a).buffer}static async encryptAesGCM(t,r,o){const i=p["default"].createCipheriv(`aes-${r.algorithm.length}-gcm`,r.data,Buffer.from(t.iv),{authTagLength:(t.tagLength||128)>>3});if(t.additionalData){i.setAAD(Buffer.from(t.additionalData))}let a=i.update(o);a=Buffer.concat([a,i.final(),i.getAuthTag()]);const c=new Uint8Array(a).buffer;return c}static async decryptAesGCM(t,r,o){const i=p["default"].createDecipheriv(`aes-${r.algorithm.length}-gcm`,r.data,new Uint8Array(t.iv));const a=(t.tagLength||128)>>3;const c=o.slice(0,o.length-a);const l=o.slice(o.length-a);if(t.additionalData){i.setAAD(Buffer.from(t.additionalData))}i.setAuthTag(l);let u=i.update(c);u=Buffer.concat([u,i.final()]);return new Uint8Array(u).buffer}static async encryptAesKW(t,r,o){const i=p["default"].createCipheriv(`id-aes${r.algorithm.length}-wrap`,r.data,this.AES_KW_IV);let a=i.update(o);a=Buffer.concat([a,i.final()]);return new Uint8Array(a).buffer}static async decryptAesKW(t,r,o){const i=p["default"].createDecipheriv(`id-aes${r.algorithm.length}-wrap`,r.data,this.AES_KW_IV);let a=i.update(o);a=Buffer.concat([a,i.final()]);return new Uint8Array(a).buffer}static async encryptAesECB(t,r,o){const i=p["default"].createCipheriv(`aes-${r.algorithm.length}-ecb`,r.data,new Uint8Array(0));let a=i.update(o);a=Buffer.concat([a,i.final()]);const c=new Uint8Array(a).buffer;return c}static async decryptAesECB(t,r,o){const i=p["default"].createDecipheriv(`aes-${r.algorithm.length}-ecb`,r.data,new Uint8Array(0));let a=i.update(o);a=Buffer.concat([a,i.final()]);return new Uint8Array(a).buffer}}AesCrypto.AES_KW_IV=Buffer.from("A6A6A6A6A6A6A6A6","hex");class AesCbcProvider extends y.AesCbcProvider{async onGenerateKey(t,r,o){const i=await AesCrypto.generateKey({name:this.name,length:t.length},r,o);return setCryptoKey(i)}async onEncrypt(t,r,o){return AesCrypto.encrypt(t,getCryptoKey(r),new Uint8Array(o))}async onDecrypt(t,r,o){return AesCrypto.decrypt(t,getCryptoKey(r),new Uint8Array(o))}async onExportKey(t,r){return AesCrypto.exportKey(t,getCryptoKey(r))}async onImportKey(t,r,o,i,a){const c=await AesCrypto.importKey(t,r,{name:o.name},i,a);return setCryptoKey(c)}checkCryptoKey(t,r){super.checkCryptoKey(t,r);if(!(getCryptoKey(t)instanceof AesCryptoKey)){throw new TypeError("key: Is not a AesCryptoKey")}}}const b=Buffer.from([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]);const w=Buffer.from([0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,135]);const A=16;function bitShiftLeft(t){const r=Buffer.alloc(t.length);const o=t.length-1;for(let i=0;i<o;i++){r[i]=t[i]<<1;if(t[i+1]&128){r[i]+=1}}r[o]=t[o]<<1;return r}function xor(t,r){const o=Math.min(t.length,r.length);const i=Buffer.alloc(o);for(let a=0;a<o;a++){i[a]=t[a]^r[a]}return i}function aes(t,r){const o=d.createCipheriv(`aes${t.length<<3}`,t,b);const i=o.update(r);o.final();return i}function getMessageBlock(t,r){const o=Buffer.alloc(A);const i=r*A;const a=i+A;t.copy(o,0,i,a);return o}function getPaddedMessageBlock(t,r){const o=Buffer.alloc(A);const i=r*A;const a=t.length;o.fill(0);t.copy(o,0,i,a);o[a-i]=128;return o}function generateSubkeys(t){const r=aes(t,b);let o=bitShiftLeft(r);if(r[0]&128){o=xor(o,w)}let i=bitShiftLeft(o);if(o[0]&128){i=xor(i,w)}return{subkey1:o,subkey2:i}}function aesCmac(t,r){const o=generateSubkeys(t);let i=Math.ceil(r.length/A);let a;let c;if(i===0){i=1;a=false}else{a=r.length%A===0}const l=i-1;if(a){c=xor(getMessageBlock(r,l),o.subkey1)}else{c=xor(getPaddedMessageBlock(r,l),o.subkey2)}let u=b;let h;for(let o=0;o<l;o++){h=xor(u,getMessageBlock(r,o));u=aes(t,h)}h=xor(c,u);return aes(t,h)}class AesCmacProvider extends y.AesCmacProvider{async onGenerateKey(t,r,o){const i=await AesCrypto.generateKey({name:this.name,length:t.length},r,o);return setCryptoKey(i)}async onSign(t,r,o){const i=aesCmac(getCryptoKey(r).data,Buffer.from(o));return new Uint8Array(i).buffer}async onVerify(t,r,o,i){const a=await this.sign(t,r,i);return Buffer.from(o).compare(Buffer.from(a))===0}async onExportKey(t,r){return AesCrypto.exportKey(t,getCryptoKey(r))}async onImportKey(t,r,o,i,a){const c=await AesCrypto.importKey(t,r,{name:o.name},i,a);return setCryptoKey(c)}checkCryptoKey(t,r){super.checkCryptoKey(t,r);if(!(getCryptoKey(t)instanceof AesCryptoKey)){throw new TypeError("key: Is not a AesCryptoKey")}}}class AesCtrProvider extends y.AesCtrProvider{async onGenerateKey(t,r,o){const i=await AesCrypto.generateKey({name:this.name,length:t.length},r,o);return setCryptoKey(i)}async onEncrypt(t,r,o){return AesCrypto.encrypt(t,getCryptoKey(r),new Uint8Array(o))}async onDecrypt(t,r,o){return AesCrypto.decrypt(t,getCryptoKey(r),new Uint8Array(o))}async onExportKey(t,r){return AesCrypto.exportKey(t,getCryptoKey(r))}async onImportKey(t,r,o,i,a){const c=await AesCrypto.importKey(t,r,{name:o.name},i,a);return setCryptoKey(c)}checkCryptoKey(t,r){super.checkCryptoKey(t,r);if(!(getCryptoKey(t)instanceof AesCryptoKey)){throw new TypeError("key: Is not a AesCryptoKey")}}}class AesGcmProvider extends y.AesGcmProvider{async onGenerateKey(t,r,o){const i=await AesCrypto.generateKey({name:this.name,length:t.length},r,o);return setCryptoKey(i)}async onEncrypt(t,r,o){return AesCrypto.encrypt(t,getCryptoKey(r),new Uint8Array(o))}async onDecrypt(t,r,o){return AesCrypto.decrypt(t,getCryptoKey(r),new Uint8Array(o))}async onExportKey(t,r){return AesCrypto.exportKey(t,getCryptoKey(r))}async onImportKey(t,r,o,i,a){const c=await AesCrypto.importKey(t,r,{name:o.name},i,a);return setCryptoKey(c)}checkCryptoKey(t,r){super.checkCryptoKey(t,r);if(!(getCryptoKey(t)instanceof AesCryptoKey)){throw new TypeError("key: Is not a AesCryptoKey")}}}class AesKwProvider extends y.AesKwProvider{async onGenerateKey(t,r,o){const i=await AesCrypto.generateKey({name:this.name,length:t.length},r,o);return setCryptoKey(i)}async onExportKey(t,r){return AesCrypto.exportKey(t,getCryptoKey(r))}async onImportKey(t,r,o,i,a){const c=await AesCrypto.importKey(t,r,{name:o.name},i,a);return setCryptoKey(c)}async onEncrypt(t,r,o){return AesCrypto.encrypt(t,getCryptoKey(r),new Uint8Array(o))}async onDecrypt(t,r,o){return AesCrypto.decrypt(t,getCryptoKey(r),new Uint8Array(o))}checkCryptoKey(t,r){super.checkCryptoKey(t,r);if(!(getCryptoKey(t)instanceof AesCryptoKey)){throw new TypeError("key: Is not a AesCryptoKey")}}}class AesEcbProvider extends y.AesEcbProvider{async onGenerateKey(t,r,o){const i=await AesCrypto.generateKey({name:this.name,length:t.length},r,o);return setCryptoKey(i)}async onEncrypt(t,r,o){return AesCrypto.encrypt(t,getCryptoKey(r),new Uint8Array(o))}async onDecrypt(t,r,o){return AesCrypto.decrypt(t,getCryptoKey(r),new Uint8Array(o))}async onExportKey(t,r){return AesCrypto.exportKey(t,getCryptoKey(r))}async onImportKey(t,r,o,i,a){const c=await AesCrypto.importKey(t,r,{name:o.name},i,a);return setCryptoKey(c)}checkCryptoKey(t,r){super.checkCryptoKey(t,r);if(!(getCryptoKey(t)instanceof AesCryptoKey)){throw new TypeError("key: Is not a AesCryptoKey")}}}class DesCryptoKey extends SymmetricKey{get alg(){switch(this.algorithm.name.toUpperCase()){case"DES-CBC":return`DES-CBC`;case"DES-EDE3-CBC":return`3DES-CBC`;default:throw new y.AlgorithmError("Unsupported algorithm name")}}set alg(t){}}c.__decorate([l.JsonProp({name:"k",converter:m})],DesCryptoKey.prototype,"data",void 0);class DesCrypto{static async generateKey(t,r,o){const i=new DesCryptoKey;i.algorithm=t;i.extractable=r;i.usages=o;i.data=p["default"].randomBytes(t.length>>3);return i}static async exportKey(t,r){switch(t.toLowerCase()){case"jwk":return l.JsonSerializer.toJSON(r);case"raw":return new Uint8Array(r.data).buffer;default:throw new y.OperationError("format: Must be 'jwk' or 'raw'")}}static async importKey(t,r,o,i,a){let c;switch(t.toLowerCase()){case"jwk":c=l.JsonParser.fromJSON(r,{targetSchema:DesCryptoKey});break;case"raw":c=new DesCryptoKey;c.data=Buffer.from(r);break;default:throw new y.OperationError("format: Must be 'jwk' or 'raw'")}c.algorithm=o;c.extractable=i;c.usages=a;return c}static async encrypt(t,r,o){switch(t.name.toUpperCase()){case"DES-CBC":return this.encryptDesCBC(t,r,Buffer.from(o));case"DES-EDE3-CBC":return this.encryptDesEDE3CBC(t,r,Buffer.from(o));default:throw new y.OperationError("algorithm: Is not recognized")}}static async decrypt(t,r,o){if(!(r instanceof DesCryptoKey)){throw new Error("key: Is not DesCryptoKey")}switch(t.name.toUpperCase()){case"DES-CBC":return this.decryptDesCBC(t,r,Buffer.from(o));case"DES-EDE3-CBC":return this.decryptDesEDE3CBC(t,r,Buffer.from(o));default:throw new y.OperationError("algorithm: Is not recognized")}}static async encryptDesCBC(t,r,o){const i=p["default"].createCipheriv(`des-cbc`,r.data,new Uint8Array(t.iv));let a=i.update(o);a=Buffer.concat([a,i.final()]);const c=new Uint8Array(a).buffer;return c}static async decryptDesCBC(t,r,o){const i=p["default"].createDecipheriv(`des-cbc`,r.data,new Uint8Array(t.iv));let a=i.update(o);a=Buffer.concat([a,i.final()]);return new Uint8Array(a).buffer}static async encryptDesEDE3CBC(t,r,o){const i=p["default"].createCipheriv(`des-ede3-cbc`,r.data,Buffer.from(t.iv));let a=i.update(o);a=Buffer.concat([a,i.final()]);const c=new Uint8Array(a).buffer;return c}static async decryptDesEDE3CBC(t,r,o){const i=p["default"].createDecipheriv(`des-ede3-cbc`,r.data,new Uint8Array(t.iv));let a=i.update(o);a=Buffer.concat([a,i.final()]);return new Uint8Array(a).buffer}}class DesCbcProvider extends y.DesProvider{constructor(){super(...arguments);this.keySizeBits=64;this.ivSize=8;this.name="DES-CBC"}async onGenerateKey(t,r,o){const i=await DesCrypto.generateKey({name:this.name,length:this.keySizeBits},r,o);return setCryptoKey(i)}async onEncrypt(t,r,o){return DesCrypto.encrypt(t,getCryptoKey(r),new Uint8Array(o))}async onDecrypt(t,r,o){return DesCrypto.decrypt(t,getCryptoKey(r),new Uint8Array(o))}async onExportKey(t,r){return DesCrypto.exportKey(t,getCryptoKey(r))}async onImportKey(t,r,o,i,a){const c=await DesCrypto.importKey(t,r,{name:this.name,length:this.keySizeBits},i,a);if(c.data.length!==this.keySizeBits>>3){throw new y.OperationError("keyData: Wrong key size")}return setCryptoKey(c)}checkCryptoKey(t,r){super.checkCryptoKey(t,r);if(!(getCryptoKey(t)instanceof DesCryptoKey)){throw new TypeError("key: Is not a DesCryptoKey")}}}class DesEde3CbcProvider extends y.DesProvider{constructor(){super(...arguments);this.keySizeBits=192;this.ivSize=8;this.name="DES-EDE3-CBC"}async onGenerateKey(t,r,o){const i=await DesCrypto.generateKey({name:this.name,length:this.keySizeBits},r,o);return setCryptoKey(i)}async onEncrypt(t,r,o){return DesCrypto.encrypt(t,getCryptoKey(r),new Uint8Array(o))}async onDecrypt(t,r,o){return DesCrypto.decrypt(t,getCryptoKey(r),new Uint8Array(o))}async onExportKey(t,r){return DesCrypto.exportKey(t,getCryptoKey(r))}async onImportKey(t,r,o,i,a){const c=await DesCrypto.importKey(t,r,{name:this.name,length:this.keySizeBits},i,a);if(c.data.length!==this.keySizeBits>>3){throw new y.OperationError("keyData: Wrong key size")}return setCryptoKey(c)}checkCryptoKey(t,r){super.checkCryptoKey(t,r);if(!(getCryptoKey(t)instanceof DesCryptoKey)){throw new TypeError("key: Is not a DesCryptoKey")}}}function getJwkAlgorithm(t){switch(t.name.toUpperCase()){case"RSA-OAEP":{const r=/(\d+)$/.exec(t.hash.name)[1];return`RSA-OAEP${r!=="1"?`-${r}`:""}`}case"RSASSA-PKCS1-V1_5":return`RS${/(\d+)$/.exec(t.hash.name)[1]}`;case"RSA-PSS":return`PS${/(\d+)$/.exec(t.hash.name)[1]}`;case"RSA-PKCS1":return`RS1`;default:throw new y.OperationError("algorithm: Is not recognized")}}class RsaPrivateKey extends AsymmetricKey{constructor(){super(...arguments);this.type="private"}getKey(){const t=h.AsnParser.parse(this.data,y.asn1.PrivateKeyInfo);return h.AsnParser.parse(t.privateKey,y.asn1.RsaPrivateKey)}toJSON(){const t=this.getKey();const r={kty:"RSA",alg:getJwkAlgorithm(this.algorithm),key_ops:this.usages,ext:this.extractable};return Object.assign(r,l.JsonSerializer.toJSON(t))}fromJSON(t){const r=l.JsonParser.fromJSON(t,{targetSchema:y.asn1.RsaPrivateKey});const o=new y.asn1.PrivateKeyInfo;o.privateKeyAlgorithm.algorithm="1.2.840.113549.1.1.1";o.privateKeyAlgorithm.parameters=null;o.privateKey=h.AsnSerializer.serialize(r);this.data=Buffer.from(h.AsnSerializer.serialize(o))}}class RsaPublicKey extends AsymmetricKey{constructor(){super(...arguments);this.type="public"}getKey(){const t=h.AsnParser.parse(this.data,y.asn1.PublicKeyInfo);return h.AsnParser.parse(t.publicKey,y.asn1.RsaPublicKey)}toJSON(){const t=this.getKey();const r={kty:"RSA",alg:getJwkAlgorithm(this.algorithm),key_ops:this.usages,ext:this.extractable};return Object.assign(r,l.JsonSerializer.toJSON(t))}fromJSON(t){const r=l.JsonParser.fromJSON(t,{targetSchema:y.asn1.RsaPublicKey});const o=new y.asn1.PublicKeyInfo;o.publicKeyAlgorithm.algorithm="1.2.840.113549.1.1.1";o.publicKeyAlgorithm.parameters=null;o.publicKey=h.AsnSerializer.serialize(r);this.data=Buffer.from(h.AsnSerializer.serialize(o))}}class RsaCrypto{static async generateKey(t,r,o){const i=new RsaPrivateKey;i.algorithm=t;i.extractable=r;i.usages=o.filter((t=>this.privateKeyUsages.indexOf(t)!==-1));const a=new RsaPublicKey;a.algorithm=t;a.extractable=true;a.usages=o.filter((t=>this.publicKeyUsages.indexOf(t)!==-1));const c=Buffer.concat([Buffer.alloc(4-t.publicExponent.byteLength,0),Buffer.from(t.publicExponent)]).readInt32BE(0);const l=p["default"].generateKeyPairSync("rsa",{modulusLength:t.modulusLength,publicExponent:c,publicKeyEncoding:{format:"der",type:"spki"},privateKeyEncoding:{format:"der",type:"pkcs8"}});i.data=l.privateKey;a.data=l.publicKey;const u={privateKey:i,publicKey:a};return u}static async exportKey(t,r){switch(t.toLowerCase()){case"jwk":return l.JsonSerializer.toJSON(r);case"pkcs8":case"spki":return new Uint8Array(r.data).buffer;default:throw new y.OperationError("format: Must be 'jwk', 'pkcs8' or 'spki'")}}static async importKey(t,r,o,i,a){switch(t.toLowerCase()){case"jwk":{const t=r;if(t.d){const t=l.JsonParser.fromJSON(r,{targetSchema:y.asn1.RsaPrivateKey});return this.importPrivateKey(t,o,i,a)}else{const t=l.JsonParser.fromJSON(r,{targetSchema:y.asn1.RsaPublicKey});return this.importPublicKey(t,o,i,a)}}case"spki":{const t=h.AsnParser.parse(new Uint8Array(r),y.asn1.PublicKeyInfo);const c=h.AsnParser.parse(t.publicKey,y.asn1.RsaPublicKey);return this.importPublicKey(c,o,i,a)}case"pkcs8":{const t=h.AsnParser.parse(new Uint8Array(r),y.asn1.PrivateKeyInfo);const c=h.AsnParser.parse(t.privateKey,y.asn1.RsaPrivateKey);return this.importPrivateKey(c,o,i,a)}default:throw new y.OperationError("format: Must be 'jwk', 'pkcs8' or 'spki'")}}static async sign(t,r,o){switch(t.name.toUpperCase()){case"RSA-PSS":case"RSASSA-PKCS1-V1_5":return this.signRsa(t,r,o);default:throw new y.OperationError("algorithm: Is not recognized")}}static async verify(t,r,o,i){switch(t.name.toUpperCase()){case"RSA-PSS":case"RSASSA-PKCS1-V1_5":return this.verifySSA(t,r,i,o);default:throw new y.OperationError("algorithm: Is not recognized")}}static async encrypt(t,r,o){switch(t.name.toUpperCase()){case"RSA-OAEP":return this.encryptOAEP(t,r,o);default:throw new y.OperationError("algorithm: Is not recognized")}}static async decrypt(t,r,o){switch(t.name.toUpperCase()){case"RSA-OAEP":return this.decryptOAEP(t,r,o);default:throw new y.OperationError("algorithm: Is not recognized")}}static importPrivateKey(t,r,o,i){const a=new y.asn1.PrivateKeyInfo;a.privateKeyAlgorithm.algorithm="1.2.840.113549.1.1.1";a.privateKeyAlgorithm.parameters=null;a.privateKey=h.AsnSerializer.serialize(t);const c=new RsaPrivateKey;c.data=Buffer.from(h.AsnSerializer.serialize(a));c.algorithm=Object.assign({},r);c.algorithm.publicExponent=new Uint8Array(t.publicExponent);c.algorithm.modulusLength=t.modulus.byteLength<<3;c.extractable=o;c.usages=i;return c}static importPublicKey(t,r,o,i){const a=new y.asn1.PublicKeyInfo;a.publicKeyAlgorithm.algorithm="1.2.840.113549.1.1.1";a.publicKeyAlgorithm.parameters=null;a.publicKey=h.AsnSerializer.serialize(t);const c=new RsaPublicKey;c.data=Buffer.from(h.AsnSerializer.serialize(a));c.algorithm=Object.assign({},r);c.algorithm.publicExponent=new Uint8Array(t.publicExponent);c.algorithm.modulusLength=t.modulus.byteLength<<3;c.extractable=o;c.usages=i;return c}static getCryptoAlgorithm(t){switch(t.hash.name.toUpperCase()){case"SHA-1":return"RSA-SHA1";case"SHA-256":return"RSA-SHA256";case"SHA-384":return"RSA-SHA384";case"SHA-512":return"RSA-SHA512";default:throw new y.OperationError("algorithm.hash: Is not recognized")}}static signRsa(t,r,o){const i=this.getCryptoAlgorithm(r.algorithm);const a=p["default"].createSign(i);a.update(Buffer.from(o));if(!r.pem){r.pem=`-----BEGIN PRIVATE KEY-----\n${r.data.toString("base64")}\n-----END PRIVATE KEY-----`}const c={key:r.pem};if(t.name.toUpperCase()==="RSA-PSS"){c.padding=p["default"].constants.RSA_PKCS1_PSS_PADDING;c.saltLength=t.saltLength}const l=a.sign(c);return new Uint8Array(l).buffer}static verifySSA(t,r,o,i){const a=this.getCryptoAlgorithm(r.algorithm);const c=p["default"].createVerify(a);c.update(Buffer.from(o));if(!r.pem){r.pem=`-----BEGIN PUBLIC KEY-----\n${r.data.toString("base64")}\n-----END PUBLIC KEY-----`}const l={key:r.pem};if(t.name.toUpperCase()==="RSA-PSS"){l.padding=p["default"].constants.RSA_PKCS1_PSS_PADDING;l.saltLength=t.saltLength}const u=c.verify(l,i);return u}static encryptOAEP(t,r,o){const i={key:`-----BEGIN PUBLIC KEY-----\n${r.data.toString("base64")}\n-----END PUBLIC KEY-----`,padding:p["default"].constants.RSA_PKCS1_OAEP_PADDING};if(t.label);return new Uint8Array(p["default"].publicEncrypt(i,o)).buffer}static decryptOAEP(t,r,o){const i={key:`-----BEGIN PRIVATE KEY-----\n${r.data.toString("base64")}\n-----END PRIVATE KEY-----`,padding:p["default"].constants.RSA_PKCS1_OAEP_PADDING};if(t.label);return new Uint8Array(p["default"].privateDecrypt(i,o)).buffer}}RsaCrypto.publicKeyUsages=["verify","encrypt","wrapKey"];RsaCrypto.privateKeyUsages=["sign","decrypt","unwrapKey"];class RsaSsaProvider extends y.RsaSsaProvider{async onGenerateKey(t,r,o){const i=await RsaCrypto.generateKey({...t,name:this.name},r,o);return{privateKey:setCryptoKey(i.privateKey),publicKey:setCryptoKey(i.publicKey)}}async onSign(t,r,o){return RsaCrypto.sign(t,getCryptoKey(r),new Uint8Array(o))}async onVerify(t,r,o,i){return RsaCrypto.verify(t,getCryptoKey(r),new Uint8Array(o),new Uint8Array(i))}async onExportKey(t,r){return RsaCrypto.exportKey(t,getCryptoKey(r))}async onImportKey(t,r,o,i,a){const c=await RsaCrypto.importKey(t,r,{...o,name:this.name},i,a);return setCryptoKey(c)}checkCryptoKey(t,r){super.checkCryptoKey(t,r);const o=getCryptoKey(t);if(!(o instanceof RsaPrivateKey||o instanceof RsaPublicKey)){throw new TypeError("key: Is not RSA CryptoKey")}}}class RsaPssProvider extends y.RsaPssProvider{async onGenerateKey(t,r,o){const i=await RsaCrypto.generateKey({...t,name:this.name},r,o);return{privateKey:setCryptoKey(i.privateKey),publicKey:setCryptoKey(i.publicKey)}}async onSign(t,r,o){return RsaCrypto.sign(t,getCryptoKey(r),new Uint8Array(o))}async onVerify(t,r,o,i){return RsaCrypto.verify(t,getCryptoKey(r),new Uint8Array(o),new Uint8Array(i))}async onExportKey(t,r){return RsaCrypto.exportKey(t,getCryptoKey(r))}async onImportKey(t,r,o,i,a){const c=await RsaCrypto.importKey(t,r,{...o,name:this.name},i,a);return setCryptoKey(c)}checkCryptoKey(t,r){super.checkCryptoKey(t,r);const o=getCryptoKey(t);if(!(o instanceof RsaPrivateKey||o instanceof RsaPublicKey)){throw new TypeError("key: Is not RSA CryptoKey")}}}class ShaCrypto{static size(t){switch(t.name.toUpperCase()){case"SHA-1":return 160;case"SHA-256":return 256;case"SHA-384":return 384;case"SHA-512":return 512;default:throw new Error("Unrecognized name")}}static digest(t,r){const o=p["default"].createHash(t.name.replace("-","")).update(Buffer.from(r)).digest();return new Uint8Array(o).buffer}}class RsaOaepProvider extends y.RsaOaepProvider{async onGenerateKey(t,r,o){const i=await RsaCrypto.generateKey({...t,name:this.name},r,o);return{privateKey:setCryptoKey(i.privateKey),publicKey:setCryptoKey(i.publicKey)}}async onEncrypt(t,r,o){const i=getCryptoKey(r);const a=new Uint8Array(o);const c=Math.ceil(i.algorithm.modulusLength>>3);const l=ShaCrypto.size(i.algorithm.hash)>>3;const u=a.byteLength;const h=c-u-2*l-2;if(u>c-2*l-2){throw new Error("Data too large")}const d=new Uint8Array(c);const g=d.subarray(1,l+1);const m=d.subarray(l+1);m.set(a,l+h+1);const v=p["default"].createHash(i.algorithm.hash.name.replace("-","")).update(y.BufferSourceConverter.toUint8Array(t.label||new Uint8Array(0))).digest();m.set(v,0);m[l+h]=1;p["default"].randomFillSync(g);const b=this.mgf1(i.algorithm.hash,g,m.length);for(let t=0;t<m.length;t++){m[t]^=b[t]}const w=this.mgf1(i.algorithm.hash,m,g.length);for(let t=0;t<g.length;t++){g[t]^=w[t]}if(!i.pem){i.pem=`-----BEGIN PUBLIC KEY-----\n${i.data.toString("base64")}\n-----END PUBLIC KEY-----`}const A=p["default"].publicEncrypt({key:i.pem,padding:p["default"].constants.RSA_NO_PADDING},Buffer.from(d));return new Uint8Array(A).buffer}async onDecrypt(t,r,o){const i=getCryptoKey(r);const a=Math.ceil(i.algorithm.modulusLength>>3);const c=ShaCrypto.size(i.algorithm.hash)>>3;const l=o.byteLength;if(l!==a){throw new Error("Bad data")}if(!i.pem){i.pem=`-----BEGIN PRIVATE KEY-----\n${i.data.toString("base64")}\n-----END PRIVATE KEY-----`}let u=p["default"].privateDecrypt({key:i.pem,padding:p["default"].constants.RSA_NO_PADDING},Buffer.from(o));const h=u[0];const d=u.subarray(1,c+1);const g=u.subarray(c+1);if(h!==0){throw new Error("Decryption failed")}const m=this.mgf1(i.algorithm.hash,g,d.length);for(let t=0;t<d.length;t++){d[t]^=m[t]}const v=this.mgf1(i.algorithm.hash,d,g.length);for(let t=0;t<g.length;t++){g[t]^=v[t]}const b=p["default"].createHash(i.algorithm.hash.name.replace("-","")).update(y.BufferSourceConverter.toUint8Array(t.label||new Uint8Array(0))).digest();for(let t=0;t<c;t++){if(b[t]!==g[t]){throw new Error("Decryption failed")}}let w=c;for(;w<g.length;w++){const t=g[w];if(t===1){break}if(t!==0){throw new Error("Decryption failed")}}if(w===g.length){throw new Error("Decryption failed")}u=g.subarray(w+1);return new Uint8Array(u).buffer}async onExportKey(t,r){return RsaCrypto.exportKey(t,getCryptoKey(r))}async onImportKey(t,r,o,i,a){const c=await RsaCrypto.importKey(t,r,{...o,name:this.name},i,a);return setCryptoKey(c)}checkCryptoKey(t,r){super.checkCryptoKey(t,r);const o=getCryptoKey(t);if(!(o instanceof RsaPrivateKey||o instanceof RsaPublicKey)){throw new TypeError("key: Is not RSA CryptoKey")}}mgf1(t,r,o=0){const i=ShaCrypto.size(t)>>3;const a=new Uint8Array(o);const c=new Uint8Array(4);const l=Math.ceil(o/i);for(let o=0;o<l;o++){c[0]=o>>>24;c[1]=o>>>16&255;c[2]=o>>>8&255;c[3]=o&255;const l=a.subarray(o*i);let u=p["default"].createHash(t.name.replace("-","")).update(r).update(c).digest();if(u.length>l.length){u=u.subarray(0,l.length)}l.set(u)}return a}}class RsaEsProvider extends y.ProviderCrypto{constructor(){super(...arguments);this.name="RSAES-PKCS1-v1_5";this.usages={publicKey:["encrypt","wrapKey"],privateKey:["decrypt","unwrapKey"]}}async onGenerateKey(t,r,o){const i=await RsaCrypto.generateKey({...t,name:this.name},r,o);return{privateKey:setCryptoKey(i.privateKey),publicKey:setCryptoKey(i.publicKey)}}checkGenerateKeyParams(t){this.checkRequiredProperty(t,"publicExponent");if(!(t.publicExponent&&t.publicExponent instanceof Uint8Array)){throw new TypeError("publicExponent: Missing or not a Uint8Array")}const r=u.Convert.ToBase64(t.publicExponent);if(!(r==="Aw=="||r==="AQAB")){throw new TypeError("publicExponent: Must be [3] or [1,0,1]")}this.checkRequiredProperty(t,"modulusLength");switch(t.modulusLength){case 1024:case 2048:case 4096:break;default:throw new TypeError("modulusLength: Must be 1024, 2048, or 4096")}}async onEncrypt(t,r,o){const i=this.toCryptoOptions(r);const a=d.publicEncrypt(i,new Uint8Array(o));return new Uint8Array(a).buffer}async onDecrypt(t,r,o){const i=this.toCryptoOptions(r);const a=d.privateDecrypt(i,new Uint8Array(o));return new Uint8Array(a).buffer}async onExportKey(t,r){return RsaCrypto.exportKey(t,getCryptoKey(r))}async onImportKey(t,r,o,i,a){const c=await RsaCrypto.importKey(t,r,{...o,name:this.name},i,a);return setCryptoKey(c)}checkCryptoKey(t,r){super.checkCryptoKey(t,r);const o=getCryptoKey(t);if(!(o instanceof RsaPrivateKey||o instanceof RsaPublicKey)){throw new TypeError("key: Is not RSA CryptoKey")}}toCryptoOptions(t){const r=t.type.toUpperCase();return{key:`-----BEGIN ${r} KEY-----\n${getCryptoKey(t).data.toString("base64")}\n-----END ${r} KEY-----`,padding:d.constants.RSA_PKCS1_PADDING}}}const B={"1.2.840.10045.3.1.7":"P-256","P-256":"1.2.840.10045.3.1.7","1.3.132.0.34":"P-384","P-384":"1.3.132.0.34","1.3.132.0.35":"P-521","P-521":"1.3.132.0.35","1.3.132.0.10":"K-256","K-256":"1.3.132.0.10"};function getOidByNamedCurve$1(t){const r=B[t];if(!r){throw new y.OperationError(`Cannot convert WebCrypto named curve '${t}' to OID`)}return r}class EcPrivateKey extends AsymmetricKey{constructor(){super(...arguments);this.type="private"}getKey(){const t=h.AsnParser.parse(this.data,y.asn1.PrivateKeyInfo);return h.AsnParser.parse(t.privateKey,y.asn1.EcPrivateKey)}toJSON(){const t=this.getKey();const r={kty:"EC",crv:this.algorithm.namedCurve,key_ops:this.usages,ext:this.extractable};return Object.assign(r,l.JsonSerializer.toJSON(t))}fromJSON(t){if(!t.crv){throw new y.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`)}const r=new y.asn1.PrivateKeyInfo;r.privateKeyAlgorithm.algorithm="1.2.840.10045.2.1";r.privateKeyAlgorithm.parameters=h.AsnSerializer.serialize(new y.asn1.ObjectIdentifier(getOidByNamedCurve$1(t.crv)));const o=l.JsonParser.fromJSON(t,{targetSchema:y.asn1.EcPrivateKey});r.privateKey=h.AsnSerializer.serialize(o);this.data=Buffer.from(h.AsnSerializer.serialize(r));return this}}class EcPublicKey extends AsymmetricKey{constructor(){super(...arguments);this.type="public"}getKey(){const t=h.AsnParser.parse(this.data,y.asn1.PublicKeyInfo);return new y.asn1.EcPublicKey(t.publicKey)}toJSON(){const t=this.getKey();const r={kty:"EC",crv:this.algorithm.namedCurve,key_ops:this.usages,ext:this.extractable};return Object.assign(r,l.JsonSerializer.toJSON(t))}fromJSON(t){if(!t.crv){throw new y.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`)}const r=l.JsonParser.fromJSON(t,{targetSchema:y.asn1.EcPublicKey});const o=new y.asn1.PublicKeyInfo;o.publicKeyAlgorithm.algorithm="1.2.840.10045.2.1";o.publicKeyAlgorithm.parameters=h.AsnSerializer.serialize(new y.asn1.ObjectIdentifier(getOidByNamedCurve$1(t.crv)));o.publicKey=h.AsnSerializer.toASN(r).valueHex;this.data=Buffer.from(h.AsnSerializer.serialize(o));return this}}class EcCrypto{static async generateKey(t,r,o){const i=new EcPrivateKey;i.algorithm=t;i.extractable=r;i.usages=o.filter((t=>this.privateKeyUsages.indexOf(t)!==-1));const a=new EcPublicKey;a.algorithm=t;a.extractable=true;a.usages=o.filter((t=>this.publicKeyUsages.indexOf(t)!==-1));const c=p["default"].generateKeyPairSync("ec",{namedCurve:this.getOpenSSLNamedCurve(t.namedCurve),publicKeyEncoding:{format:"der",type:"spki"},privateKeyEncoding:{format:"der",type:"pkcs8"}});i.data=c.privateKey;a.data=c.publicKey;const l={privateKey:i,publicKey:a};return l}static async sign(t,r,o){const i=t.hash.name.replace("-","");const a=p["default"].createSign(i);a.update(Buffer.from(o));if(!r.pem){r.pem=`-----BEGIN PRIVATE KEY-----\n${r.data.toString("base64")}\n-----END PRIVATE KEY-----`}const c={key:r.pem};const l=a.sign(c);const u=h.AsnParser.parse(l,y.asn1.EcDsaSignature);const d=this.getPointSize(r.algorithm.namedCurve);const g=this.addPadding(d,Buffer.from(u.r));const m=this.addPadding(d,Buffer.from(u.s));const v=new Uint8Array(Buffer.concat([g,m])).buffer;return v}static async verify(t,r,o,i){const a=t.hash.name.replace("-","");const c=p["default"].createVerify(a);c.update(Buffer.from(i));if(!r.pem){r.pem=`-----BEGIN PUBLIC KEY-----\n${r.data.toString("base64")}\n-----END PUBLIC KEY-----`}const l={key:r.pem};const u=new y.asn1.EcDsaSignature;const d=this.getPointSize(r.algorithm.namedCurve);u.r=this.removePadding(o.slice(0,d));u.s=this.removePadding(o.slice(d,d+d));const g=Buffer.from(h.AsnSerializer.serialize(u));const m=c.verify(l,g);return m}static async deriveBits(t,r,o){const i=this.getOpenSSLNamedCurve(r.algorithm.namedCurve);const a=p["default"].createECDH(i);const c=h.AsnParser.parse(r.data,y.asn1.PrivateKeyInfo);const l=h.AsnParser.parse(c.privateKey,y.asn1.EcPrivateKey);a.setPrivateKey(Buffer.from(l.privateKey));const u=h.AsnParser.parse(t.public.data,y.asn1.PublicKeyInfo);const d=a.computeSecret(Buffer.from(u.publicKey));return new Uint8Array(d).buffer.slice(0,o>>3)}static async exportKey(t,r){switch(t.toLowerCase()){case"jwk":return l.JsonSerializer.toJSON(r);case"pkcs8":case"spki":return new Uint8Array(r.data).buffer;case"raw":{const t=h.AsnParser.parse(r.data,y.asn1.PublicKeyInfo);return t.publicKey}default:throw new y.OperationError("format: Must be 'jwk', 'raw', pkcs8' or 'spki'")}}static async importKey(t,r,o,i,a){switch(t.toLowerCase()){case"jwk":{const t=r;if(t.d){const t=l.JsonParser.fromJSON(r,{targetSchema:y.asn1.EcPrivateKey});return this.importPrivateKey(t,o,i,a)}else{const t=l.JsonParser.fromJSON(r,{targetSchema:y.asn1.EcPublicKey});return this.importPublicKey(t,o,i,a)}}case"raw":{const t=new y.asn1.EcPublicKey(r);return this.importPublicKey(t,o,i,a)}case"spki":{const t=h.AsnParser.parse(new Uint8Array(r),y.asn1.PublicKeyInfo);const c=new y.asn1.EcPublicKey(t.publicKey);this.assertKeyParameters(t.publicKeyAlgorithm.parameters,o.namedCurve);return this.importPublicKey(c,o,i,a)}case"pkcs8":{const t=h.AsnParser.parse(new Uint8Array(r),y.asn1.PrivateKeyInfo);const c=h.AsnParser.parse(t.privateKey,y.asn1.EcPrivateKey);this.assertKeyParameters(t.privateKeyAlgorithm.parameters,o.namedCurve);return this.importPrivateKey(c,o,i,a)}default:throw new y.OperationError("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'")}}static assertKeyParameters(t,r){if(!t){throw new y.CryptoError("Key info doesn't have required parameters")}let o="";try{o=h.AsnParser.parse(t,y.asn1.ObjectIdentifier).value}catch(t){throw new y.CryptoError("Cannot read key info parameters")}if(getOidByNamedCurve$1(r)!==o){throw new y.CryptoError("Key info parameter doesn't match to named curve")}}static async importPrivateKey(t,r,o,i){const a=new y.asn1.PrivateKeyInfo;a.privateKeyAlgorithm.algorithm="1.2.840.10045.2.1";a.privateKeyAlgorithm.parameters=h.AsnSerializer.serialize(new y.asn1.ObjectIdentifier(getOidByNamedCurve$1(r.namedCurve)));a.privateKey=h.AsnSerializer.serialize(t);const c=new EcPrivateKey;c.data=Buffer.from(h.AsnSerializer.serialize(a));c.algorithm=Object.assign({},r);c.extractable=o;c.usages=i;return c}static async importPublicKey(t,r,o,i){const a=new y.asn1.PublicKeyInfo;a.publicKeyAlgorithm.algorithm="1.2.840.10045.2.1";const c=getOidByNamedCurve$1(r.namedCurve);a.publicKeyAlgorithm.parameters=h.AsnSerializer.serialize(new y.asn1.ObjectIdentifier(c));a.publicKey=t.value;const l=new EcPublicKey;l.data=Buffer.from(h.AsnSerializer.serialize(a));l.algorithm=Object.assign({},r);l.extractable=o;l.usages=i;return l}static getOpenSSLNamedCurve(t){switch(t.toUpperCase()){case"P-256":return"prime256v1";case"K-256":return"secp256k1";case"P-384":return"secp384r1";case"P-521":return"secp521r1";default:throw new y.OperationError(`Cannot convert WebCrypto named curve to NodeJs. Unknown name '${t}'`)}}static getPointSize(t){switch(t){case"P-256":case"K-256":return 32;case"P-384":return 48;case"P-521":return 66;default:throw new Error(`Cannot get size for the named curve '${t}'`)}}static addPadding(t,r){const o=Buffer.alloc(t);o.set(Buffer.from(r),t-r.length);return o}static removePadding(t){for(let r=0;r<t.length;r++){if(!t[r]){continue}return t.slice(r).buffer}return new ArrayBuffer(0)}}EcCrypto.publicKeyUsages=["verify"];EcCrypto.privateKeyUsages=["sign","deriveKey","deriveBits"];class EcdsaProvider extends y.EcdsaProvider{constructor(){super(...arguments);this.namedCurves=["P-256","P-384","P-521","K-256"]}async onGenerateKey(t,r,o){const i=await EcCrypto.generateKey({...t,name:this.name},r,o);return{privateKey:setCryptoKey(i.privateKey),publicKey:setCryptoKey(i.publicKey)}}async onSign(t,r,o){return EcCrypto.sign(t,getCryptoKey(r),new Uint8Array(o))}async onVerify(t,r,o,i){return EcCrypto.verify(t,getCryptoKey(r),new Uint8Array(o),new Uint8Array(i))}async onExportKey(t,r){return EcCrypto.exportKey(t,getCryptoKey(r))}async onImportKey(t,r,o,i,a){const c=await EcCrypto.importKey(t,r,{...o,name:this.name},i,a);return setCryptoKey(c)}checkCryptoKey(t,r){super.checkCryptoKey(t,r);const o=getCryptoKey(t);if(!(o instanceof EcPrivateKey||o instanceof EcPublicKey)){throw new TypeError("key: Is not EC CryptoKey")}}}class EcdhProvider extends y.EcdhProvider{async onGenerateKey(t,r,o){const i=await EcCrypto.generateKey({...t,name:this.name},r,o);return{privateKey:setCryptoKey(i.privateKey),publicKey:setCryptoKey(i.publicKey)}}async onExportKey(t,r){return EcCrypto.exportKey(t,getCryptoKey(r))}async onImportKey(t,r,o,i,a){const c=await EcCrypto.importKey(t,r,{...o,name:this.name},i,a);return setCryptoKey(c)}checkCryptoKey(t,r){super.checkCryptoKey(t,r);const o=getCryptoKey(t);if(!(o instanceof EcPrivateKey||o instanceof EcPublicKey)){throw new TypeError("key: Is not EC CryptoKey")}}async onDeriveBits(t,r,o){const i=await EcCrypto.deriveBits({...t,public:getCryptoKey(t.public)},getCryptoKey(r),o);return i}}const S={[y.asn1.idEd448]:"Ed448",ed448:y.asn1.idEd448,[y.asn1.idX448]:"X448",x448:y.asn1.idX448,[y.asn1.idEd25519]:"Ed25519",ed25519:y.asn1.idEd25519,[y.asn1.idX25519]:"X25519",x25519:y.asn1.idX25519};function getOidByNamedCurve(t){const r=S[t.toLowerCase()];if(!r){throw new y.OperationError(`Cannot convert WebCrypto named curve '${t}' to OID`)}return r}class EdPrivateKey extends AsymmetricKey{constructor(){super(...arguments);this.type="private"}getKey(){const t=h.AsnParser.parse(this.data,y.asn1.PrivateKeyInfo);return h.AsnParser.parse(t.privateKey,y.asn1.CurvePrivateKey)}toJSON(){const t=this.getKey();const r={kty:"OKP",crv:this.algorithm.namedCurve,key_ops:this.usages,ext:this.extractable};return Object.assign(r,l.JsonSerializer.toJSON(t))}fromJSON(t){if(!t.crv){throw new y.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`)}const r=new y.asn1.PrivateKeyInfo;r.privateKeyAlgorithm.algorithm=getOidByNamedCurve(t.crv);const o=l.JsonParser.fromJSON(t,{targetSchema:y.asn1.CurvePrivateKey});r.privateKey=h.AsnSerializer.serialize(o);this.data=Buffer.from(h.AsnSerializer.serialize(r));return this}}class EdPublicKey extends AsymmetricKey{constructor(){super(...arguments);this.type="public"}getKey(){const t=h.AsnParser.parse(this.data,y.asn1.PublicKeyInfo);return t.publicKey}toJSON(){const t=this.getKey();const r={kty:"OKP",crv:this.algorithm.namedCurve,key_ops:this.usages,ext:this.extractable};return Object.assign(r,{x:u.Convert.ToBase64Url(t)})}fromJSON(t){if(!t.crv){throw new y.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`)}if(!t.x){throw new y.OperationError(`Cannot get property from JWK. Property 'x' is required`)}const r=new y.asn1.PublicKeyInfo;r.publicKeyAlgorithm.algorithm=getOidByNamedCurve(t.crv);r.publicKey=u.Convert.FromBase64Url(t.x);this.data=Buffer.from(h.AsnSerializer.serialize(r));return this}}class EdCrypto{static async generateKey(t,r,o){const i=new EdPrivateKey;i.algorithm=t;i.extractable=r;i.usages=o.filter((t=>this.privateKeyUsages.indexOf(t)!==-1));const a=new EdPublicKey;a.algorithm=t;a.extractable=true;a.usages=o.filter((t=>this.publicKeyUsages.indexOf(t)!==-1));const c=t.namedCurve.toLowerCase();const l=p["default"].generateKeyPairSync(c,{publicKeyEncoding:{format:"der",type:"spki"},privateKeyEncoding:{format:"der",type:"pkcs8"}});i.data=l.privateKey;a.data=l.publicKey;const u={privateKey:i,publicKey:a};return u}static async sign(t,r,o){if(!r.pem){r.pem=`-----BEGIN PRIVATE KEY-----\n${r.data.toString("base64")}\n-----END PRIVATE KEY-----`}const i={key:r.pem};const a=p["default"].sign(null,Buffer.from(o),i);return y.BufferSourceConverter.toArrayBuffer(a)}static async verify(t,r,o,i){if(!r.pem){r.pem=`-----BEGIN PUBLIC KEY-----\n${r.data.toString("base64")}\n-----END PUBLIC KEY-----`}const a={key:r.pem};const c=p["default"].verify(null,Buffer.from(i),a,Buffer.from(o));return c}static async deriveBits(t,r,o){const i=p["default"].createPublicKey({key:t.public.data,format:"der",type:"spki"});const a=p["default"].createPrivateKey({key:r.data,format:"der",type:"pkcs8"});const c=p["default"].diffieHellman({publicKey:i,privateKey:a});return new Uint8Array(c).buffer.slice(0,o>>3)}static async exportKey(t,r){switch(t.toLowerCase()){case"jwk":return l.JsonSerializer.toJSON(r);case"pkcs8":case"spki":return new Uint8Array(r.data).buffer;case"raw":{const t=h.AsnParser.parse(r.data,y.asn1.PublicKeyInfo);return t.publicKey}default:throw new y.OperationError("format: Must be 'jwk', 'raw', pkcs8' or 'spki'")}}static async importKey(t,r,o,i,a){switch(t.toLowerCase()){case"jwk":{const t=r;if(t.d){const t=l.JsonParser.fromJSON(r,{targetSchema:y.asn1.CurvePrivateKey});return this.importPrivateKey(t,o,i,a)}else{if(!t.x){throw new TypeError("keyData: Cannot get required 'x' filed")}return this.importPublicKey(u.Convert.FromBase64Url(t.x),o,i,a)}}case"raw":{return this.importPublicKey(r,o,i,a)}case"spki":{const t=h.AsnParser.parse(new Uint8Array(r),y.asn1.PublicKeyInfo);return this.importPublicKey(t.publicKey,o,i,a)}case"pkcs8":{const t=h.AsnParser.parse(new Uint8Array(r),y.asn1.PrivateKeyInfo);const c=h.AsnParser.parse(t.privateKey,y.asn1.CurvePrivateKey);return this.importPrivateKey(c,o,i,a)}default:throw new y.OperationError("format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'")}}static importPrivateKey(t,r,o,i){const a=new EdPrivateKey;a.fromJSON({crv:r.namedCurve,d:u.Convert.ToBase64Url(t.d)});a.algorithm=Object.assign({},r);a.extractable=o;a.usages=i;return a}static async importPublicKey(t,r,o,i){const a=new EdPublicKey;a.fromJSON({crv:r.namedCurve,x:u.Convert.ToBase64Url(t)});a.algorithm=Object.assign({},r);a.extractable=o;a.usages=i;return a}}EdCrypto.publicKeyUsages=["verify"];EdCrypto.privateKeyUsages=["sign","deriveKey","deriveBits"];class EdDsaProvider extends y.EdDsaProvider{async onGenerateKey(t,r,o){const i=await EdCrypto.generateKey({name:this.name,namedCurve:t.namedCurve.replace(/^ed/i,"Ed")},r,o);return{privateKey:setCryptoKey(i.privateKey),publicKey:setCryptoKey(i.publicKey)}}async onSign(t,r,o){return EdCrypto.sign(t,getCryptoKey(r),new Uint8Array(o))}async onVerify(t,r,o,i){return EdCrypto.verify(t,getCryptoKey(r),new Uint8Array(o),new Uint8Array(i))}async onExportKey(t,r){return EdCrypto.exportKey(t,getCryptoKey(r))}async onImportKey(t,r,o,i,a){const c=await EdCrypto.importKey(t,r,{...o,name:this.name},i,a);return setCryptoKey(c)}}class EcdhEsProvider extends y.EcdhEsProvider{async onGenerateKey(t,r,o){const i=await EdCrypto.generateKey({name:this.name,namedCurve:t.namedCurve.toUpperCase()},r,o);return{privateKey:setCryptoKey(i.privateKey),publicKey:setCryptoKey(i.publicKey)}}async onDeriveBits(t,r,o){const i=await EdCrypto.deriveBits({...t,public:getCryptoKey(t.public)},getCryptoKey(r),o);return i}async onExportKey(t,r){return EdCrypto.exportKey(t,getCryptoKey(r))}async onImportKey(t,r,o,i,a){const c=await EdCrypto.importKey(t,r,{...o,name:this.name},i,a);return setCryptoKey(c)}}class Sha1Provider extends y.ProviderCrypto{constructor(){super(...arguments);this.name="SHA-1";this.usages=[]}async onDigest(t,r){return ShaCrypto.digest(t,r)}}class Sha256Provider extends y.ProviderCrypto{constructor(){super(...arguments);this.name="SHA-256";this.usages=[]}async onDigest(t,r){return ShaCrypto.digest(t,r)}}class Sha384Provider extends y.ProviderCrypto{constructor(){super(...arguments);this.name="SHA-384";this.usages=[]}async onDigest(t,r){return ShaCrypto.digest(t,r)}}class Sha512Provider extends y.ProviderCrypto{constructor(){super(...arguments);this.name="SHA-512";this.usages=[]}async onDigest(t,r){return ShaCrypto.digest(t,r)}}class PbkdfCryptoKey extends CryptoKey{}class Pbkdf2Provider extends y.Pbkdf2Provider{async onDeriveBits(t,r,o){return new Promise(((i,a)=>{const c=y.BufferSourceConverter.toArrayBuffer(t.salt);const l=t.hash.name.replace("-","");p["default"].pbkdf2(getCryptoKey(r).data,Buffer.from(c),t.iterations,o>>3,l,((t,r)=>{if(t){a(t)}else{i(new Uint8Array(r).buffer)}}))}))}async onImportKey(t,r,o,i,a){if(t==="raw"){const t=new PbkdfCryptoKey;t.data=Buffer.from(r);t.algorithm={name:this.name};t.extractable=false;t.usages=a;return setCryptoKey(t)}throw new y.OperationError("format: Must be 'raw'")}checkCryptoKey(t,r){super.checkCryptoKey(t,r);if(!(getCryptoKey(t)instanceof PbkdfCryptoKey)){throw new TypeError("key: Is not PBKDF CryptoKey")}}}class HmacCryptoKey extends CryptoKey{get alg(){const t=this.algorithm.hash.name.toUpperCase();return`HS${t.replace("SHA-","")}`}set alg(t){}}c.__decorate([l.JsonProp({name:"k",converter:m})],HmacCryptoKey.prototype,"data",void 0);class HmacProvider extends y.HmacProvider{async onGenerateKey(t,r,o){const i=(t.length||this.getDefaultLength(t.hash.name))>>3<<3;const a=new HmacCryptoKey;a.algorithm={...t,length:i,name:this.name};a.extractable=r;a.usages=o;a.data=p["default"].randomBytes(i>>3);return setCryptoKey(a)}async onSign(t,r,o){const i=r.algorithm.hash.name.replace("-","");const a=p["default"].createHmac(i,getCryptoKey(r).data).update(Buffer.from(o)).digest();return new Uint8Array(a).buffer}async onVerify(t,r,o,i){const a=r.algorithm.hash.name.replace("-","");const c=p["default"].createHmac(a,getCryptoKey(r).data).update(Buffer.from(i)).digest();return c.compare(Buffer.from(o))===0}async onImportKey(t,r,o,i,a){let c;switch(t.toLowerCase()){case"jwk":c=l.JsonParser.fromJSON(r,{targetSchema:HmacCryptoKey});break;case"raw":c=new HmacCryptoKey;c.data=Buffer.from(r);break;default:throw new y.OperationError("format: Must be 'jwk' or 'raw'")}c.algorithm={hash:{name:o.hash.name},name:this.name,length:c.data.length<<3};c.extractable=i;c.usages=a;return setCryptoKey(c)}async onExportKey(t,r){switch(t.toLowerCase()){case"jwk":return l.JsonSerializer.toJSON(getCryptoKey(r));case"raw":return new Uint8Array(getCryptoKey(r).data).buffer;default:throw new y.OperationError("format: Must be 'jwk' or 'raw'")}}checkCryptoKey(t,r){super.checkCryptoKey(t,r);if(!(getCryptoKey(t)instanceof HmacCryptoKey)){throw new TypeError("key: Is not HMAC CryptoKey")}}}class HkdfCryptoKey extends CryptoKey{}class HkdfProvider extends y.HkdfProvider{async onImportKey(t,r,o,i,a){if(t.toLowerCase()!=="raw"){throw new y.OperationError("Operation not supported")}const c=new HkdfCryptoKey;c.data=Buffer.from(r);c.algorithm={name:this.name};c.extractable=i;c.usages=a;return setCryptoKey(c)}async onDeriveBits(t,o,i){const a=t.hash.name.replace("-","");const c=p["default"].createHash(a).digest().length;const l=i/8;const u=r.BufferSourceConverter.toUint8Array(t.info);const h=p["default"].createHmac(a,r.BufferSourceConverter.toUint8Array(t.salt)).update(r.BufferSourceConverter.toUint8Array(getCryptoKey(o).data)).digest();const y=[Buffer.alloc(0)];const d=Math.ceil(l/c)+1;for(let t=1;t<d;++t){y.push(p["default"].createHmac(a,h).update(Buffer.concat([y[t-1],u,Buffer.from([t])])).digest())}return Buffer.concat(y).slice(0,l)}checkCryptoKey(t,r){super.checkCryptoKey(t,r);if(!(getCryptoKey(t)instanceof HkdfCryptoKey)){throw new TypeError("key: Is not HKDF CryptoKey")}}}class SubtleCrypto extends y.SubtleCrypto{constructor(){var t;super();this.providers.set(new AesCbcProvider);this.providers.set(new AesCtrProvider);this.providers.set(new AesGcmProvider);this.providers.set(new AesCmacProvider);this.providers.set(new AesKwProvider);this.providers.set(new AesEcbProvider);this.providers.set(new DesCbcProvider);this.providers.set(new DesEde3CbcProvider);this.providers.set(new RsaSsaProvider);this.providers.set(new RsaPssProvider);this.providers.set(new RsaOaepProvider);this.providers.set(new RsaEsProvider);this.providers.set(new EcdsaProvider);this.providers.set(new EcdhProvider);this.providers.set(new Sha1Provider);this.providers.set(new Sha256Provider);this.providers.set(new Sha384Provider);this.providers.set(new Sha512Provider);this.providers.set(new Pbkdf2Provider);this.providers.set(new HmacProvider);this.providers.set(new HkdfProvider);const r=(t=/^v(\d+)/.exec(g.version))===null||t===void 0?void 0:t[1];if(r&&parseInt(r,10)>=14){this.providers.set(new EdDsaProvider);this.providers.set(new EcdhEsProvider)}}}class Crypto extends y.Crypto{constructor(){super(...arguments);this.subtle=new SubtleCrypto}getRandomValues(t){const r=Buffer.from(t.buffer);p["default"].randomFillSync(r);return t}}Object.defineProperty(t,"CryptoKey",{enumerable:true,get:function(){return r.CryptoKey}});t.Crypto=Crypto})();module.exports=o})();